library Meshes
{
    Line(self: Points3D, index: Integer2): Line3D
        => (self[index.A], self[index.B]);

    Triangle(self: Points3D, index: Integer3): Triangle3D
        => (self[index.A], self[index.B], self[index.C]);
    
    Quad(self: Points3D, index: Integer4): Quad3D
        => (self[index.A], self[index.B], self[index.C], self[index.D]);    
    
    Line(self: IPointGeometry3D, index: Integer2): Line3D
        => self.Points.GetLine(index);

    Triangle(self: IPointGeometry3D, index: Integer3): Triangle3D
        => self.Points.GetTriangle(index);
        
    Quad(self: IPointGeometry3D, index: Integer4): Quad3D
        => self.Points.GetQuad(index);

    Lines(self: LineMesh3D): Lines3D
        => self.FaceIndices.Map(fi => self.Line(fi));

    Triangles(self: TriangleMesh3D): Triangles3D
        => self.FaceIndices.Map(fi => self.Triangle(fi));
    
    Quads(self: QuadMesh3D): Quads3D
        => self.FaceIndices.Map(fi => self.Quad(fi));

    Transform(self: Deformable3D, t: Transform3D): Self
        => self.Deform(self, p => p.Transform(t));

    Transform(self: Point3D, t: Transform3D): Point3D
        => t.Matrix * self;

    Deform(line: Line3D, f: Function1<Point3D, Point3D>): Line3D
        => (f(line.A), f(line.B));

    Deform(triangle: Triangle3D, f: Function1<Point3D, Point3D>): Triangle3D
        => (f(triangle.A), f(triangle.B), f(triangle.C));

    Deform(quad: Quad3D, f: Function1<Point3D, Point3D>): Quad3D
        => (f(quad.A), f(quad.B), f(quad.C), f(quad.D));

    Deform(self: IPrimitiveGeometry3D<$T>, f: Function1<Point3D, Point3D>): IPrimitiveGeometry3D<$T>
        where $T: IDeformable3D
        => self.Primitives.Map(p => p.Deform(f));

    Deform(self: IPointGeometry3D, f: Function1<Point3D, Point3D>): IPointGeometry3D
        => self.WithPoints(p => p.Deform(f));

    Bounds(g: IPointGeometry3D): Bounds3D 
        => g.Points.Bounds();
         
    Points(x: Line2D): IArray<Point2D> => [x.A, x.B];
    Points(x: Line3D): IArray<Point3D> => [x.A, x.B];
    Points(x: Triangle2D): IArray<Point2D> => [x.A, x.B, x.C];
    Points(x: Triangle3D): IArray<Point3D> => [x.A, x.B, x.C];
    Points(x: Quad2D): IArray<Point2D> => [x.A, x.B, x.C, x.D];
    Points(x: Quad3D): IArray<Point3D> => [x.A, x.B, x.C, x.D];

    Lines(x: Triangle2D): IArray<Line2D> => [x.LineA, x.LineB, x.LineC];
    Lines(x: Triangle3D): IArray<Line3D> => [x.LineA, x.LineB, x.LineC];
    Lines(x: Quad2D): IArray<Line2D> => [x.LineA, x.LineB, x.LineC, x.LineD];
    Lines(x: Quad3D): IArray<Line3D> => [x.LineA, x.LineB, x.LineC, x.LineD];

    Triangles(q: Quad2D): IArray<Triangle2D> => [q.TriangleA, q.TriangleB]; 
    Triangles(q: Quad3D): IArray<Triangle3D> => [q.TriangleA, q.TriangleB];

    Points(xs: ILineArray2D): IArray<Point2D> => xs.Lines.FlatMap(x => x.Points);
    Points(xs: ILineArray3D): IArray<Point3D> => xs.Lines.FlatMap(x => x.Points);
    Points(xs: ITriangleArray2D): IArray<Point2D> => xs.Triangles.FlatMap(x => x.Points);
    Points(xs: ITriangleArray3D): IArray<Point3D> => xs.Triangles.FlatMap(x => x.Points);
    Points(xs: IQuadArray2D): IArray<Point2D> => xs.Quads.FlatMap(x => x.Points);
    Points(xs: IQuadArray3D): IArray<Point3D> => xs.Quads.FlatMap(x => x.Points);

    Lines(xs: ITriangleArray2D): IArray<Line2D> => xs.Triangles.FlatMap(x => x.Lines);
    Lines(xs: ITriangleArray3D): IArray<Line3D> => xs.Triangles.FlatMap(x => x.Lines);
    Lines(xs: IQuadArray2D): IArray<Line2D> => xs.Quads.FlatMap(x => x.Lines);
    Lines(xs: IQuadArray3D): IArray<Line3D> => xs.Quads.FlatMap(x => x.Lines);

    Triangles(xs: IQuadArray2D): IArray<Triangle2D> => xs.Quads.FlatMap(x => x.Triangles);
    Triangles(xs: IQuadArray3D): IArray<Triangle3D> => xs.Quads.FlatMap(x => x.Triangles);

    Lines(xs: IPolyLine2D): IArray<Line2D> => xs.Points.WithNext((a, b) => new Line2D(a, b), xs.Closed); 
    Lines(xs: IPolyLine3D): IArray<Line3D> => xs.Points.WithNext((a, b) => new Line3D(a, b), xs.Closed);  

    //==
    // IDeformable implementations 

    // TODO: these could all be replaced with a "WithPoints" function. 

    Deform(x: Line2D, f: Function1<Point2D, Point2D>): Line2D => (f(x.A), f(x.B));
    Deform(x: Ray2D, f: Function1<Point2D, Point2D>): Ray2D => (f(x.Origin), f(x.Origin + x.Direction).Vector2.Normalize);
    Deform(t: Triangle2D, f: Function1<Point2D, Point2D>): Triangle2D => (f(t.A), f(t.B), f(t.C));
    Deform(q: Quad2D, f: Function1<Point2D, Point2D>): Quad2D => (f(q.A), f(q.B), f(q.C), f(q.D));
    Deform(v: Point2D, f: Function1<Point2D, Point2D>): Point2D => f(v);
    Deform(x: TriangleMesh2D, f: Function1<Point2D, Point2D>): TriangleMesh2D => (x.Points.Map(f), x.FaceIndices);
    Deform(x: QuadMesh2D, f: Function1<Point2D, Point2D>): QuadMesh2D => (x.Points.Map(f), x.FaceIndices);
    Deform(x: PolyLine2D, f: Function1<Point2D, Point2D>): PolyLine2D => (x.Points.Map(f), x.Closed);
    Deform(x: LineArray2D, f: Function1<Point2D, Point2D>): LineArray2D => new LineArray2D(x.Lines.Map(l => l.Deform(f)));
    Deform(x: TriangleArray2D, f: Function1<Point2D, Point2D>): TriangleArray2D => new TriangleArray2D(x.Triangles.Map(t => t.Deform(f)));
    Deform(x: PointArray2D, f: Function1<Point2D, Point2D>): PointArray2D => new PointArray2D(x.Points.Map(f));
    Deform(x: QuadArray2D, f: Function1<Point2D, Point2D>): QuadArray2D => new QuadArray2D(x.Quads.Map(q => q.Deform(f)));
    Deform(x: QuadGrid2D, f: Function1<Point2D, Point2D>): QuadGrid2D => new QuadGrid2D(x.PointGrid.Map(f), x.ClosedX, x.ClosedY);
    Deform(x: Bounds2D, f: Function1<Point2D, Point2D>): Bounds2D => x.Corners.Map(f).Bounds();

    Deform(x: Line3D, f: Function1<Point3D, Point3D>): Line3D => (f(x.A), f(x.B));
    Deform(x: Ray3D, f: Function1<Point3D, Point3D>): Ray3D => (f(x.Origin), f(x.Origin + x.Direction).Vector3.Normalize);
    Deform(t: Triangle3D, f: Function1<Point3D, Point3D>): Triangle3D => (f(t.A), f(t.B), f(t.C));
    Deform(q: Quad3D, f: Function1<Point3D, Point3D>): Quad3D => (f(q.A), f(q.B), f(q.C), f(q.D));
    Deform(v: Point3D, f: Function1<Point3D, Point3D>): Point3D => f(v);
    Deform(x: TriangleMesh3D, f: Function1<Point3D, Point3D>): TriangleMesh3D => (x.Points.Map(f), x.FaceIndices);
    Deform(x: QuadMesh3D, f: Function1<Point3D, Point3D>): QuadMesh3D => (x.Points.Map(f), x.FaceIndices);
    Deform(x: PolyLine3D, f: Function1<Point3D, Point3D>): PolyLine3D => (x.Points.Map(f), x.Closed);
    Deform(x: LineArray3D, f: Function1<Point3D, Point3D>): LineArray3D => new LineArray3D(x.Lines.Map(l => l.Deform(f)));
    Deform(x: TriangleArray3D, f: Function1<Point3D, Point3D>): TriangleArray3D => new TriangleArray3D(x.Triangles.Map(t => t.Deform(f)));
    Deform(x: PointArray3D, f: Function1<Point3D, Point3D>): PointArray3D => new PointArray3D(x.Points.Map(f));
    Deform(x: QuadArray3D, f: Function1<Point3D, Point3D>): QuadArray3D => new QuadArray3D(x.Quads.Map(q => q.Deform(f)));
    Deform(x: QuadGrid3D, f: Function1<Point3D, Point3D>): QuadGrid3D => new QuadGrid3D(x.PointGrid.Map(f), x.ClosedX, x.ClosedY);
    Deform(x: Bounds3D, f: Function1<Point3D, Point3D>): Bounds3D => x.Corners.Map(f).Bounds();

    //==
    // Deformable functions

    // TODO: these need to become transformable functions.
  

    Deform(x: IDeformable3D, t: ITransform3D): IDeformable3D => x.Deform(v => v.Vector3.Transform(t.Matrix));

    Scale(x: IDeformable3D, v: Vector3): IDeformable3D => x.Deform(p => p.Vector3 * v);
    Scale(x: IDeformable3D, s: Number): IDeformable3D => x.Scale((s,s,s));
    ScaleX(x: IDeformable3D, s: Number): IDeformable3D => x.Scale((s,1,1));
    ScaleY(x: IDeformable3D, s: Number): IDeformable3D => x.Scale((1,s,1));
    ScaleZ(x: IDeformable3D, s: Number): IDeformable3D => x.Scale((1,1,s));

    Rotate(x: IDeformable3D, q: Quaternion): IDeformable3D => x.Deform(v => q.Transform(v));
    RotateX(x: IDeformable3D, a: Angle): IDeformable3D => x.Rotate(a.RotateX);
    RotateY(x: IDeformable3D, a: Angle): IDeformable3D => x.Rotate(a.RotateY);
    RotateZ(x: IDeformable3D, a: Angle): IDeformable3D => x.Rotate(a.RotateZ);

    Translate(x: IDeformable3D, v: Vector3): IDeformable3D => x.Deform(p => p + v);
    TranslateX(x: IDeformable3D, s: Number): IDeformable3D => x.Translate(s.XVector3);
    TranslateY(x: IDeformable3D, s: Number): IDeformable3D => x.Translate(s.YVector3);
    TranslateZ(x: IDeformable3D, s: Number): IDeformable3D => x.Translate(s.ZVector3);
 
    //==
    // QuadGrid2D and QuadGrid3D

    NumColumns(x: QuadGrid2D): Integer => x.Grid.NumColumns;
    NumRows(x: QuadGrid2D): Integer => x.Grid.NumRows;
    Points(x: QuadGrid2D): IArray<Point2D> => x.Grid;
    FaceIndices(x: QuadGrid2D): IArray<Integer4> => x.Grid.AllQuadFaceIndices(x.ClosedX, x.ClosedY);

    NumColumns(x: QuadGrid3D): Integer => x.Grid.NumColumns;
    NumRows(x: QuadGrid3D): Integer => x.Grid.NumRows;
    Points(x: QuadGrid3D): IArray<Point3D> => x.Grid;
    FaceIndices(x: QuadGrid3D): IArray<Integer4> => x.Grid.AllQuadFaceIndices(x.ClosedX, x.ClosedY);

    // d -- c
    // |    |
    // a -- b
    // Where a == (col,row), b == (col+1,row), c == (col+1,row+1), d == (col,row+1)
    QuadFaceIndices(col: Integer, row: Integer, nCols: Integer, nRows: Integer): Integer4
    {
        var a = (row * nCols) + col;
        var b = (row * nCols) + ((col + 1) % nCols);
        var c = (((row + 1) % nRows) * nCols) + ((col + 1) % nCols);
        var d = (((row + 1) % nRows) * nCols) + col;
        return (a, b, c, d);
    }

    AllQuadFaceIndices(xs: IArray2D<$T>, closedX: Boolean, closedY: Boolean): IArray2D<Integer4>
        => AllQuadFaceIndices(xs.NumColumns, xs.NumRows, closedX, closedY);

    AllQuadFaceIndices(nCols: Integer, nRows: Integer, closedX: Boolean, closedY: Boolean): IArray2D<Integer4>
    {
        var nx = nCols - (closedX ? 0 : 1);
        var ny = nRows - (closedY ? 0 : 1);
        return nx.MakeArray2D(ny, (col, row) => QuadFaceIndices(col, row, nCols, nRows));
    }
}