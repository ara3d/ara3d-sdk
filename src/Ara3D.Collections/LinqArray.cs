using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace Ara3D.Collections
{
    /// <summary>
    /// Extension functions for working on any object implementing IArray. This overrides
    /// many of the Linq functions providing better performance.
    /// </summary>
    public static class LinqArray
    {
        /// <summary>
        /// Creates an IArray with the given number of items,
        /// and uses the function to return items.
        /// </summary>
        public static ReadOnlyList<T> Select<T>(this int count, Func<int, T> f)
            => new ReadOnlyList<T>(count, f);

        /// <summary>
        /// Creates an IArray by repeating each item in the source a number of times.
        /// </summary>
        public static ReadOnlyList<T> RepeatElements<T>(this IReadOnlyList<T> self, int count)
            => Select(self.Count * count, i => self[i / count]);

        /// <summary>
        /// Creates an IArray starting with a seed value, and applying a function
        /// to each individual member of the array. This is eagerly evaluated.
        /// </summary>
        public static T[] Generate<T>(this T init, int count, Func<T, T> f)
        {
            var r = new T[count];
            for (var i = 0; i < count; ++i)
            {
                r[i] = init;
                init = f(init);
            }

            return r;
        }

        /// <summary>
        /// Creates an IArray of integers from zero up to one less than the given number.
        /// </summary>
        public static IntegerRange Range(this int self)
            => new IntegerRange(0, self);

        /// <summary>
        /// Creates an IArray of integers from a to one less than b.
        /// </summary>
        public static IntegerRange UpTo(this int a, int b)
            => new IntegerRange(a, b - a);


        /// <summary>
        /// Returns true if and only if the argument is a valid index into the array.
        /// </summary>
        public static bool InRange<T>(this IReadOnlyList<T> self, int n)
            => n >= 0 && n < self.Count;

        /// <summary>
        /// A mnemonic for "Any()" that returns false if the count is greater than zero
        /// </summary>
        public static bool IsEmpty<T>(this IReadOnlyList<T> self)
            => self.Count == 0;

        /// <summary>
        /// Returns true if there are any elements in the array.
        /// </summary>
        public static bool Any<T>(this IReadOnlyList<T> self)
            => self.Count != 0;

        /// <summary>
        /// Converts the IArray into a system array.
        /// </summary>
        public static T[] ToArray<T>(this IReadOnlyList<T> self)
            => self.CopyTo(new T[self.Count]);

        /// <summary>
        /// Converts the array into a function that returns values from an integer, returning a default value if out of range.
        /// </summary>
        public static Func<int, T> ToFunction<T>(this IReadOnlyList<T> self, T def = default)
            => i => self.InRange(i) ? self[i] : def;

        /// <summary>
        /// Converts the array into a predicate (a function that returns true or false) based on the truth of the given value.
        /// </summary>
        public static Func<int, bool> ToPredicate(this IReadOnlyList<bool> self)
            => self.ToFunction();

        /// <summary>
        /// Adds all elements of the array to the target collection.
        /// </summary>
        public static U AddTo<T, U>(this IReadOnlyList<T> self, U other) where U : ICollection<T>
        {
            for (var i = 0; i < self.Count; ++i)
                other.Add(self[i]);
            return other;
        }

        /// <summary>
        /// Copies all elements of the array to the target list or array, starting at the provided index.
        /// </summary>
        public static U CopyTo<T, U>(this IReadOnlyList<T> self, U other, int destIndex = 0) where U : IList<T>
        {
            for (var i = 0; i < self.Count; ++i)
                other[i + destIndex] = self[i];
            return other;
        }

        /// <summary>
        /// Returns an array generated by applying a function to each element.
        /// </summary>
        public static ReadOnlyList<U> Select<T, U>(this IReadOnlyList<T> self, Func<T, U> f)
            => Select(self.Count, i => f(self[i]));

        /// <summary>
        /// Returns an array generated by applying a function to each element.
        /// </summary>
        public static ReadOnlyList<U> Select<T, U>(this IReadOnlyList<T> self, Func<T, int, U> f)
            => Select(self.Count, i => f(self[i], i));

        /// <summary>
        /// Returns an array generated by applying a function to each element.
        /// </summary>
        public static ReadOnlyList<U> SelectIndices<T, U>(this IReadOnlyList<T> self, Func<int, U> f)
            => self.Count.Select(f);

        /// <summary>
        /// Converts an array of array into a flattened array. Each array is assumed to be of size stride.
        /// </summary>
        public static ReadOnlyList<T> Flatten<T>(this IReadOnlyList<IReadOnlyList<T>> self, int n)
            => Select(self.Count * n, i => self[i / n][i % n]);

        /// <summary>
        /// Converts an array of array into a flattened array.
        /// </summary>
        public static T[] Flatten<T>(this IReadOnlyList<IReadOnlyList<T>> self)
        {
            var counts = self.Select(x => x.Count).PostAccumulate((x, y) => x + y);
            var r = new T[counts.Last()];
            var i = 0;
            foreach (var xs in self)
                xs.CopyTo(r, counts[i++]);
            return r;
        }

        /// <summary>
        /// Returns an array of tuple where each element of the initial array is paired with its index.
        /// </summary>
        public static ReadOnlyList<(T value, int index)> ZipWithIndex<T>(this IReadOnlyList<T> self)
            => self.Select((v, i) => (v, i));

        /// <summary>
        /// Returns an array from an array of arrays, where the number of sub-elements is the same for reach array and is known.
        /// </summary>
        public static ReadOnlyList<T> SelectMany<T>(this IReadOnlyList<IReadOnlyList<T>> self, int count)
            => Select(self.Count, i => self[i / count][i % count]);

        /// <summary>
        /// Returns an array given a function that generates an IArray from each member. Eager evaluation.
        /// </summary>
        public static List<U> SelectMany<T, U>(this IReadOnlyList<T> self, Func<T, IReadOnlyList<U>> func)
        {
            var xs = new List<U>();
            for (var i = 0; i < self.Count; ++i)
                func(self[i]).AddTo(xs);
            return xs;
        }

        /// <summary>
        /// Returns an array given a function that generates an IArray from each member. Eager evaluation.
        /// </summary>
        public static List<U> SelectMany<T, U>(this IReadOnlyList<T> self, Func<T, int, IReadOnlyList<U>> func)
        {
            var xs = new List<U>();
            for (var i = 0; i < self.Count; ++i)
                func(self[i], i).AddTo(xs);
            return xs;
        }

        /// <summary>
        /// Returns an array given a function that generates a tuple from each member. Eager evaluation.
        /// </summary>
        public static U[] SelectMany<T, U>(this IReadOnlyList<T> self, Func<T, Tuple<U, U>> func)
        {
            var r = new U[self.Count * 2];
            for (var i = 0; i < self.Count; ++i)
            {
                var tmp = func(self[i]);
                r[i * 2] = tmp.Item1;
                r[i * 2 + 1] = tmp.Item2;
            }

            return r;
        }

        /// <summary>
        /// Returns an array given a function that generates a tuple from each member. Eager evaluation.
        /// </summary>
        public static U[] SelectMany<T, U>(this IReadOnlyList<T> self, Func<T, Tuple<U, U, U>> func)
        {
            var r = new U[self.Count * 3];
            for (var i = 0; i < self.Count; ++i)
            {
                var tmp = func(self[i]);
                r[i * 3] = tmp.Item1;
                r[i * 3 + 1] = tmp.Item2;
                r[i * 3 + 2] = tmp.Item3;
            }

            return r;
        }

        /// <summary>
        /// Returns an array given a function that generates a tuple from each member. Eager evaluation.
        /// </summary>
        public static U[] SelectMany<T, U>(this IReadOnlyList<T> self, Func<T, Tuple<U, U, U, U>> func)
        {
            var r = new U[self.Count * 4];
            for (var i = 0; i < self.Count; ++i)
            {
                var tmp = func(self[i]);
                r[i * 4] = tmp.Item1;
                r[i * 4 + 1] = tmp.Item2;
                r[i * 4 + 2] = tmp.Item3;
                r[i * 4 + 3] = tmp.Item4;
            }

            return r;
        }

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<V> Zip<T, U, V>(this IReadOnlyList<T> self, IReadOnlyList<U> other, Func<T, U, V> f)
            => Select(Math.Min(self.Count, other.Count), i => f(self[i], other[i]));

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<V> Zip<T, U, V>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            Func<T, U, int, V> f)
            => Select(Math.Min(self.Count, other.Count), i => f(self[i], other[i], i));

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<W> Zip<T, U, V, W>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            IReadOnlyList<V> other2, Func<T, U, V, W> f)
            => Select(Math.Min(Math.Min(self.Count, other.Count), other2.Count), i => f(self[i], other[i], other2[i]));

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<W> Zip<T, U, V, W>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            IReadOnlyList<V> other2, Func<T, U, V, int, W> f)
            => Select(Math.Min(Math.Min(self.Count, other.Count), other2.Count),
                i => f(self[i], other[i], other2[i], i));

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<X> Zip<T, U, V, W, X>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            IReadOnlyList<V> other2, IReadOnlyList<W> other3, Func<T, U, V, W, X> f)
            => Select(Math.Min(Math.Min(self.Count, other.Count), Math.Min(other2.Count, other3.Count)),
                i => f(self[i], other[i], other2[i], other3[i]));

        /// <summary>
        /// Returns an array generated by applying a function to corresponding pairs of elements in both arrays.
        /// </summary>
        public static ReadOnlyList<X> Zip<T, U, V, W, X>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            IReadOnlyList<V> other2, IReadOnlyList<W> other3, Func<T, U, V, W, int, X> f)
            => Select(Math.Min(Math.Min(self.Count, other.Count), Math.Min(other2.Count, other3.Count)),
                i => f(self[i], other[i], other2[i], other3[i], i));

        /// <summary>
        /// Applies a function to each element in the list paired with the next one.
        /// Used to implement adjacent differences for example.
        /// </summary>
        public static ReadOnlyList<U> ZipEachWithNext<T, U>(this IReadOnlyList<T> self, Func<T, T, U> f)
            => self.Zip(self.Skip(), f);

        /// <summary>
        /// Returns an IEnumerable containing only elements of the array for which the function returns true on the index.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<T> WhereIndices<T>(this IReadOnlyList<T> self, Func<int, bool> f)
            => self.Where((x, i) => f(i));

        /// <summary>
        /// Returns an IEnumerable containing only elements of the array for which the corresponding mask is true.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<T> Where<T>(this IReadOnlyList<T> self, IReadOnlyList<bool> mask)
            => self.WhereIndices(mask.ToPredicate());

        /// <summary>
        /// Returns an IEnumerable containing only indices of the array for which the function satisfies a specific predicate.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<int> IndicesWhere<T>(this IReadOnlyList<T> self, Func<T, bool> f)
            => self.Indices().Where(i => f(self[i]));

        /// <summary>
        /// Returns an IEnumerable containing only indices of the array for which the function satisfies a specific predicate.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<int> IndicesWhere<T>(this IReadOnlyList<T> self, Func<T, int, bool> f)
            => self.IndicesWhere(i => f(self[i], i));

        /// <summary>
        /// Returns an IEnumerable containing only indices of the array for which the function satisfies a specific predicate.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<int> IndicesWhere<T>(this IReadOnlyList<T> self, Func<int, bool> f)
            => self.Indices().Where(i => f(i));

        /// <summary>
        /// Returns an IEnumerable containing only indices of the array for which booleans in the mask are true.
        /// An IArray is not created automatically because it is an expensive operation that is potentially unneeded.
        /// </summary>
        public static IEnumerable<int> IndicesWhere<T>(this IReadOnlyList<T> self, IReadOnlyList<bool> mask)
            => self.IndicesWhere(mask.ToPredicate());

        /// <summary>
        /// Shortcut for ToEnumerable.Aggregate()
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static U Aggregate<T, U>(this IReadOnlyList<T> self, U init, Func<U, T, U> func)
        {
            for (var i = 0; i < self.Count; ++i)
                init = func(init, self[i]);
            return init;
        }

        /// <summary>
        /// Shortcut for ToEnumerable.Aggregate()
        /// </summary>
        public static U Aggregate<T, U>(this IReadOnlyList<T> self, Func<U, T, U> func)
            => Aggregate(self, default, func);

        /// <summary>
        /// Shortcut for ToEnumerable.Aggregate()
        /// </summary>
        public static U Aggregate<T, U>(this IReadOnlyList<T> self, U init, Func<U, T, int, U> func)
        {
            for (var i = 0; i < self.Count; ++i)
                init = func(init, self[i], i);
            return init;
        }

        /// <summary>
        /// Shortcut for ToEnumerable.Aggregate()
        /// </summary>
        public static U Aggregate<T, U>(this IReadOnlyList<T> self, Func<U, T, int, U> func)
            => Aggregate(self, default, func);

        /// <summary>
        /// Returns a new array containing the elements in the range of from to to
        /// </summary>
        public static ReadOnlyList<T> Slice<T>(this IReadOnlyList<T> self, int from, int to)
            => Select(to - from, i => self[i + from]);

        /// <summary>
        /// Returns a 2D array where each row is a slice. 
        /// </summary>
        public static ReadOnlyList2D<T> Slices<T>(this IReadOnlyList<T> self, int size)
            => new ReadOnlyList2D<T>(self, size, self.Count / size);

        /// <summary>
        /// Returns stride elements of the list starting from a given index.
        /// </summary>
        public static ReadOnlyList<T> SubArray<T>(this IReadOnlyList<T> self, int from, int count)
            => self.Slice(from, count + from);

        /// <summary>
        /// Returns elements of the array between from and skipping every stride element.
        /// </summary>
        public static ReadOnlyList<T> Slice<T>(this IReadOnlyList<T> self, int from, int to, int stride)
            => Select((to - from) / stride, i => self[i * stride + from]);

        /// <summary>
        /// Returns a new array containing the elements by taking every nth item.
        /// </summary>
        public static ReadOnlyList<T> Stride<T>(this IReadOnlyList<T> self, int stride)
            => self.Stride(0, stride);

        /// <summary>
        /// Returns a new array containing the elements by taking every nth item.
        /// </summary>
        public static ReadOnlyList<T> Stride<T>(this IReadOnlyList<T> self, int from, int stride)
            => Select((self.Count - from) / stride, i => self[from + i * stride]);

        /// <summary>
        /// Returns a new array containing just the first n items.
        /// </summary>
        public static ReadOnlyList<T> Take<T>(this IReadOnlyList<T> self, int n)
            => self.Slice(0, n);

        /// <summary>
        /// Returns a new array containing just at most n items.
        /// </summary>
        public static ReadOnlyList<T> TakeAtMost<T>(this IReadOnlyList<T> self, int n)
            => self.Count > n ? self.Slice(0, n) : self.Slice(0, self.Count);

        /// <summary>
        /// Returns a new array containing the elements after the first stride elements.
        /// </summary>
        public static ReadOnlyList<T> Skip<T>(this IReadOnlyList<T> self, int n = 1)
            => self.Slice(n, self.Count);

        /// <summary>
        /// Returns a new array containing the last stride elements.
        /// </summary>
        public static ReadOnlyList<T> TakeLast<T>(this IReadOnlyList<T> self, int n = 1)
            => self.Skip(self.Count - n);

        /// <summary>
        /// Returns a new array containing all elements excluding the last stride elements.
        /// </summary>
        public static ReadOnlyList<T> DropLast<T>(this IReadOnlyList<T> self, int n = 1)
            => self.Count > n ? self.Take(self.Count - n) : self.Take(0);

        /// <summary>
        /// Returns a new array by remapping indices
        /// </summary>
        public static ReadOnlyList<T> MapIndices<T>(this IReadOnlyList<T> self, Func<int, int> f)
            => self.Count.Select(i => self[f(i)]);

        /// <summary>
        /// Returns an array by selecting every "nth" element.
        /// Unlike stride has the same number of elements as original array. 
        /// </summary>
        public static ReadOnlyList<T> SelectEveryNth<T>(this IReadOnlyList<T> self, int n)
            => self.MapIndices(i => i * n % self.Count);

        /// <summary>
        /// Returns a new array that reverses the order of elements
        /// </summary>
        public static ReadOnlyList<T> Reverse<T>(this IReadOnlyList<T> self)
            => self.MapIndices(i => self.Count - 1 - i);

        /// <summary>
        /// Uses the provided indices to select elements from the array.
        /// </summary>
        public static ReadOnlyList<T> SelectByIndex<T>(this IReadOnlyList<T> self, IReadOnlyList<int> indices)
            => indices.Select(i => self[i]);

        /// <summary>
        /// Uses the array as indices to select elements from the other array.
        /// </summary>
        public static ReadOnlyList<T> Choose<T>(this IReadOnlyList<int> indices, IReadOnlyList<T> values)
            => values.SelectByIndex(indices);

        /// <summary>
        /// Given indices of sub-arrays groups, this will convert it to arrays of indices (e.g. [0, 2] with a group size of 3 becomes [0, 1, 2, 6, 7, 8])
        /// </summary>
        public static IReadOnlyList<int> GroupIndicesToIndices(this IReadOnlyList<int> indices, int groupSize)
            => groupSize == 1
                ? indices
                : (indices.Count * groupSize).Select(i => indices[i / groupSize] * groupSize + i % groupSize);

        /// <summary>
        /// Return the array separated into a series of groups (similar to DictionaryOfLists)
        /// based on keys created by the given keySelector
        /// </summary>
        public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IReadOnlyList<TSource> self,
            Func<TSource, TKey> keySelector)
            => self.GroupBy(keySelector);

        /// <summary>
        /// Return the array separated into a series of groups (similar to DictionaryOfLists)
        /// based on keys created by the given keySelector and elements chosen by the element selector
        /// </summary>
        public static IEnumerable<IGrouping<TKey, TElem>> GroupBy<TSource, TKey, TElem>(
            this IReadOnlyList<TSource> self, Func<TSource, TKey> keySelector, Func<TSource, TElem> elementSelector)
            => self.GroupBy(keySelector, elementSelector);

        /// <summary>
        /// Uses the provided indices to select groups of contiguous elements from the array.
        /// This is equivalent to self.SubArrays(groupSize).SelectByIndex(indices).SelectMany();
        /// </summary>
        public static IReadOnlyList<T> SelectGroupsByIndex<T>(this IReadOnlyList<T> self, int groupSize,
            IReadOnlyList<int> indices)
            => self.SelectByIndex(indices.GroupIndicesToIndices(groupSize));

        /// <summary>
        /// Similar to take, if count is less than the number of items in the array, otherwise uses a modulo operation.
        /// </summary>
        public static ReadOnlyList<T> Resize<T>(this IReadOnlyList<T> self, int count)
            => Select(count, i => self[i % self.Count]);

        /// <summary>
        /// Returns an array of the same type with no elements.
        /// </summary>
        public static EmptyList<T> Empty<T>(this IReadOnlyList<T> self)
            => EmptyList<T>.Default;

        /// <summary>
        /// Returns an array of the same type with no elements.
        /// </summary>
        public static IReadOnlyList<T> Empty<T>()
            => EmptyList<T>.Default;

        /// <summary>
        /// Returns a sequence of integers from 0 to 1 less than the number of items in the array, representing indicies of the array.
        /// </summary>
        public static IntegerRange Indices<T>(this IReadOnlyList<T> self)
            => self.Count.Range();

        /// <summary>
        /// Converts an array of elements into a string representation
        /// </summary>
        public static string Join<T>(this IReadOnlyList<T> self, string sep = " ")
            => self.Aggregate(new StringBuilder(), (sb, x) => sb.Append(x).Append(sep)).ToString();

        /// <summary>
        /// Concatenates the contents of one array with another.
        /// </summary>
        public static ReadOnlyList<T> Concat<T>(this IReadOnlyList<T> self, IReadOnlyList<T> other)
            => Select(self.Count + other.Count, i => i < self.Count ? self[i] : other[i - self.Count]);

        /// <summary>
        /// Returns the index of the first element matching the given item.
        /// </summary>
        public static int IndexOf<T>(this IReadOnlyList<T> self, T item) where T : IEquatable<T>
            => self.IndexOf(x => x.Equals(item));

        /// <summary>
        /// Returns the index of the first element matching the given item.
        /// </summary>
        public static int IndexOf<T>(this IReadOnlyList<T> self, Func<T, bool> predicate)
        {
            for (var i = 0; i < self.Count; ++i)
            {
                if (predicate(self[i]))
                    return i;
            }

            return -1;
        }

        /// <summary>
        /// Returns the index of the last element matching the given item.
        /// </summary>
        public static int LastIndexOf<T>(this IReadOnlyList<T> self, T item) where T : IEquatable<T>
        {
            var n = self.Reverse().IndexOf(item);
            return n < 0 ? n : self.Count - 1 - n;
        }

        /// <summary>
        /// Returns an array that is one element shorter that subtracts each element from its previous one.
        /// </summary>
        public static ReadOnlyList<int> AdjacentDifferences(this IReadOnlyList<int> self)
            => self.ZipEachWithNext((a, b) => b - a);

        /// <summary>
        /// Creates a new array that concatenates a unit item list of one item after it.
        /// Repeatedly calling Append would result in significant performance degradation.
        /// </summary>
        public static ReadOnlyList<T> Append<T>(this IReadOnlyList<T> self, T x)
            => (self.Count + 1).Select(i => i < self.Count ? self[i] : x);

        /// <summary>
        /// Creates a new array that concatenates the given items to itself.
        /// </summary>
        public static ReadOnlyList<T> Append<T>(this IReadOnlyList<T> self, params T[] x)
            => self.Concat(x);

        /// <summary>
        /// Creates a new array that concatenates a unit item list of one item before it
        /// Repeatedly calling Prepend would result in significant performance degradation.
        /// </summary>
        public static ReadOnlyList<T> Prepend<T>(this IReadOnlyList<T> self, T x)
            => (self.Count + 1).Select(i => i == 0 ? x : self[i - 1]);

        /// <summary>
        /// Creates a new array that prepends and appends values
        /// </summary>
        public static ReadOnlyList<T> AppendAndPrepend<T>(this IReadOnlyList<T> self, T before, T after)
            => (self.Count + 2).Select(i => i == 0 ? before : i == self.Count + 1 ? after : self[i - 2]);

        /// <summary>
        /// Returns the element at the nth position,
        /// </summary>
        public static T ElementAt<T>(this IReadOnlyList<T> self, int n)
            => self[n];

        /// <summary>
        /// Returns the element at the nth position
        /// </summary>
        public static T At<T>(this IReadOnlyList<T> self, int n)
            => self[n];

        /// <summary>
        /// Returns the element at the nth position, where stride is modulo the number of items in the arrays.
        /// </summary>
        public static T AtModulo<T>(this IReadOnlyList<T> self, int n)
            => self.ElementAt((n % self.Count + self.Count) % self.Count);

        /// <summary>
        /// Returns the element at the nth position, where stride is modulo the number of items in the arrays.
        /// </summary>
        public static T ElementAtModulo<T>(this IReadOnlyList<T> self, int n)
            => self.AtModulo(n);

        /// <summary>
        /// Returns the Nth element of the array, or a default value if out of range/
        /// </summary>
        public static T ElementAtOrDefault<T>(this IReadOnlyList<T> xs, int n, T defaultValue = default)
            => xs != null && n >= 0 && n < xs.Count ? xs[n] : defaultValue;

        /// <summary>
        /// Counts all elements in an array that satisfy a predicate
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountWhere<T>(this IReadOnlyList<T> self, Func<T, bool> p)
            => self.Aggregate(0, (n, x) => n + (p(x) ? 1 : 0));

        /// <summary>
        /// Counts all elements in an array that are equal to true
        /// </summary>
        public static int CountWhere(this IReadOnlyList<bool> self)
            => self.CountWhere(x => x);

        /// <summary>
        /// Counts all elements in an array that are equal to a value
        /// </summary>
        public static int CountWhere<T>(this IReadOnlyList<T> self, T val) where T : IEquatable<T>
            => self.CountWhere(x => x.Equals(val));

        /// <summary>
        /// Returns the minimum element in the list
        /// </summary>
        public static T Min<T>(this IReadOnlyList<T> self) where T : IComparable<T>
        {
            if (self.Count == 0) throw new ArgumentOutOfRangeException();
            return self.Aggregate(self[0], (a, b) => a.CompareTo(b) < 0 ? a : b);
        }

        /// <summary>
        /// Returns the maximum element in the list
        /// </summary>
        public static T Max<T>(this IReadOnlyList<T> self) where T : IComparable<T>
        {
            if (self.Count == 0) throw new ArgumentOutOfRangeException();
            return self.Aggregate(self[0], (a, b) => a.CompareTo(b) > 0 ? a : b);
        }

        /// <summary>
        /// Applies a function (like "+") to each element in the series to create an effect similar to partial sums.
        /// </summary>
        public static T[] Accumulate<T>(this IReadOnlyList<T> self, Func<T, T, T> f)
        {
            var n = self.Count;
            var r = new T[n];
            if (n == 0) return r;
            var prev = r[0] = self[0];
            for (var i = 1; i < n; ++i)
            {
                prev = r[i] = f(prev, self[i]);
            }

            return r;
        }

        /// <summary>
        /// Applies a function (like "+") to each element in the series to create an effect similar to partial sums.
        /// The first value in the array will be zero.
        /// </summary>
        public static T[] PostAccumulate<T>(this IReadOnlyList<T> self, Func<T, T, T> f, T init = default)
        {
            var n = self.Count;
            var r = new T[n + 1];
            var prev = r[0] = init;
            for (var i = 0; i < n; ++i)
            {
                prev = r[i + 1] = f(prev, self[i]);
            }

            return r;
        }

        /// <summary>
        /// Returns true if the two lists are the same length, and the elements are the same.
        /// </summary>
        public static bool SequenceEquals<T>(this IReadOnlyList<T> self, IReadOnlyList<T> other) where T : IEquatable<T>
            => self == other || (self.Count == other.Count &&
                                 self.Zip(other, (x, y) => x?.Equals(y) ?? y == null).All(x => x));

        /// <summary>
        /// Creates a readonly array from a seed value, by applying a function
        /// </summary>
        public static List<T> Build<T>(T init, Func<T, T> next, Func<T, bool> hasNext)
        {
            var r = new List<T>();
            while (hasNext(init))
            {
                r.Add(init);
                init = next(init);
            }

            return r;
        }

        /// <summary>
        /// Creates a readonly array from a seed value, by applying a function
        /// </summary>
        public static List<T> Build<T>(T init, Func<T, int, T> next, Func<T, int, bool> hasNext)
        {
            var i = 0;
            var r = new List<T>();
            while (hasNext(init, i))
            {
                r.Add(init);
                init = next(init, ++i);
            }

            return r;
        }

        /// <summary>
        /// Creates an array of arrays, split at the given indices
        /// </summary>
        public static IReadOnlyList<IReadOnlyList<T>> Split<T>(this IReadOnlyList<T> self, IReadOnlyList<int> indices)
            => indices.Prepend(0).Zip(indices.Append(self.Count), (x, y) => self.Slice(x, y));

        /// <summary>
        /// Creates an array of arrays, split at the given index.
        /// </summary>
        public static (ReadOnlyList<T>, ReadOnlyList<T>) Split<T>(this IReadOnlyList<T> self, int index)
            => (self.Take(index), self.Skip(index));

        /// <summary>
        /// Splits an array of tuples into a tuple of array
        /// </summary>
        public static (ReadOnlyList<T1>, ReadOnlyList<T2>) Unzip<T1, T2>(this IReadOnlyList<(T1, T2)> self)
            => (self.Select(pair => pair.Item1), self.Select(pair => pair.Item2));

        /// <summary>
        /// Sums items in an array using a selector function that returns integers.
        /// </summary>
        public static long Sum<T>(this IReadOnlyList<T> self, Func<T, long> func)
            => self.Aggregate(0L, (init, x) => init + func(x));

        /// <summary>
        /// Sums items in an array using a selector function that returns doubles.
        /// </summary>
        public static double Sum<T>(this IReadOnlyList<T> self, Func<T, double> func)
            => self.Aggregate(0.0, (init, x) => init + func(x));

        /// <summary>
        /// Converts to a regular array in parallel
        /// </summary>
        public static T[] ToArrayInParallel<T>(this IReadOnlyList<T> xs)
        {
            if (xs.Count == 0)
                return Array.Empty<T>();

            if (xs.Count < Environment.ProcessorCount)
                return xs.ToArray();

            var r = new T[xs.Count];
            var partitioner = Partitioner
                .Create(0, xs.Count, xs.Count / Environment.ProcessorCount);

            Parallel.ForEach(partitioner, (range, state) =>
            {
                for (var i = range.Item1; i < range.Item2; ++i)
                    r[i] = xs[i];
            });
            return r;
        }

        /// <summary>
        /// Maps pairs of elements to a new array.
        /// </summary>
        public static ReadOnlyList<U> SelectPairs<T, U>(this IReadOnlyList<T> xs, Func<T, T, U> f)
            => (xs.Count / 2).Select(i => f(xs[i * 2], xs[i * 2 + 1]));

        /// <summary>
        /// Maps every 3 elements to a new array.
        /// </summary>
        public static ReadOnlyList<U> SelectTriplets<T, U>(this IReadOnlyList<T> xs, Func<T, T, T, U> f)
            => (xs.Count / 3).Select(i => f(xs[i * 3], xs[i * 3 + 1], xs[i * 3 + 2]));

        /// <summary>
        /// Maps every 4 elements to a new array.
        /// </summary>
        public static ReadOnlyList<U> SelectQuartets<T, U>(this IReadOnlyList<T> xs, Func<T, T, T, T, U> f)
            => (xs.Count / 4).Select(i => f(xs[i * 4], xs[i * 4 + 1], xs[i * 4 + 2], xs[i * 4 + 3]));

        /// <summary>
        /// Given an array of elements of type T casts them to a U
        /// </summary>
        public static ReadOnlyList<U> Cast<T, U>(this IReadOnlyList<T> xs) where T : U
            => xs.Select(x => (U)x);

        /// <summary>
        /// Returns true if the value is present in the array.
        /// </summary>
        public static bool Contains<T>(this IReadOnlyList<T> xs, T value)
            => xs.Any(x => x.Equals(value));

        public static T First<T>(this IReadOnlyList<T> self)
            => self[0];

        public static T FirstOrDefault<T>(this IReadOnlyList<T> xs)
            => xs.Count > 0 ? xs[0] : default;

        public static T FirstOrDefault<T>(this IReadOnlyList<T> xs, T @default)
            => xs.Count > 0 ? xs[0] : @default;

        public static T FirstOrDefault<T>(this IReadOnlyList<T> xs, Func<T, bool> predicate)
            => xs.Where(predicate).FirstOrDefault();


        /// <summary>
        /// Returns the last item in the array
        /// </summary>
        public static T Last<T>(this IReadOnlyList<T> self)
            => self[self.Count - 1];

        /// <summary>
        /// Returns the last item in the array
        /// </summary>
        public static T Last<T>(this IReadOnlyList<T> self, T @default = default)
            => self.IsEmpty() ? @default : self[self.Count - 1];

        public static T Middle<T>(this IReadOnlyList<T> self)
            => self[self.Count / 2];

        public static ReadOnlyList<long> ToLongs(this IReadOnlyList<int> xs)
            => xs.Select(x => (long)x);

        public static long[] PrefixSums(this IReadOnlyList<int> self)
            => self.ToLongs().PrefixSums();

        public static float[] PrefixSums(this IReadOnlyList<float> self)
            => self.Scan(0f, (a, b) => a + b);

        public static double[] PrefixSums(this IReadOnlyList<double> self)
            => self.Scan(0.0, (a, b) => a + b);

        public static U[] Scan<T, U>(this IReadOnlyList<T> self, U init, Func<U, T, U> scanFunc)
        {
            var r = new U[self.Count];
            for (var i = 0; i < self.Count; ++i)
                init = r[i] = scanFunc(init, self[i]);
            return r;
        }

        public static long[] PrefixSums(this IReadOnlyList<long> counts)
            => counts.Scan(0L, (a, b) => a + b);

        // Similar to prefix sums, but starts at zero.
        // r[i] = Sum(count[0 to i])
        public static int[] CountsToOffsets(this IReadOnlyList<int> counts)
        {
            var r = new int[counts.Count];
            for (var i = 1; i < counts.Count; ++i)
                r[i] = r[i - 1] + counts[i - 1];
            return r;
        }

        public static ReadOnlyList<int> OffsetsToCounts(this IReadOnlyList<int> offsets, int last)
            => offsets.Indices().Select(i => i < offsets.Count - 1 ? offsets[i + 1] - offsets[i] : last - offsets[i]);

        public static ReadOnlyList<T> SetElementAt<T>(this IReadOnlyList<T> self, int index, T value)
            => self.SelectIndices(i => i == index ? value : self[i]);

        public static IReadOnlyList<T> SetFirstElementWhere<T>(this IReadOnlyList<T> self, Func<T, bool> predicate,
            T value)
        {
            var index = self.IndexOf(predicate);
            if (index < 0)
                return self;
            return self.SetElementAt(index, value);
        }

        public static IReadOnlyList2D<V> CartesianProduct<T, U, V>(this IReadOnlyList<T> self, IReadOnlyList<U> other,
            Func<U, T, V> func)
            => self.SelectMany(y => other.Select(x => func(x, y))).ToArray2D(other.Count, self.Count);

        public static int BinarySearch<T>(this IReadOnlyList<T> self, Func<T, int> compare)
            => self.Count == 0 ? -1 : BinarySearchIndex(self, i => compare(self[i]), 0, self.Count - 1);

        /// <summary>
        /// Returns the highest index for which the comparison of f(self[index]) <= 0
        /// If f(xs[0]) < 0 returns -1
        /// </summary>
        public static int BinarySearchIndex<T>(this IReadOnlyList<T> self, Func<int, int> compare)
            => self.Count == 0 ? -1 : BinarySearchIndex(self, compare, 0, self.Count - 1);

        /// <summary>
        /// Returns the highest index for which the comparison of f(self[index]) <= 0
        /// If f(xs[0]) < 0 returns -1
        /// </summary>
        public static int BinarySearchIndex<T>(this IReadOnlyList<T> self, Func<int, int> compare, int min, int max)
        {
            var cnt = max - min;
            if (cnt <= 0)
                return min - 1;
            var mid = min + cnt / 2;
            var tmp = compare(mid);
            if (tmp == 0)
                return mid;
            if (tmp < 0)
                return self.BinarySearchIndex(compare, min, mid - 1);
            return self.BinarySearchIndex(compare, mid + 1, max);
        }

        public static ReadOnlyList<T> Repeat<T>(this T value, int count)
            => count.Select(_ => value);

        public static ReadOnlyList<T> Shift<T>(this IReadOnlyList<T> self, int shift)
            => new ReadOnlyList<T>(self.Count, i => self.AtModulo(i + shift));
    }
}