// Autogenerated file: DO NOT EDIT
// Created on 2025-06-04 10:07:55 AM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;
using Ara3D.Collections;

namespace Ara3D.Geometry
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Vector8: IVector<Vector8>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Vector8 Create(Number x0, Number x1, Number x2, Number x3, Number x4, Number x5, Number x6, Number x7) => new Vector8(x0, x1, x2, x3, x4, x5, x6, x7);

        // Static default implementation
        public static readonly Vector8 Default = default;

        // Implicit converters to/from value-tuples and deconstructor
        [MethodImpl(AggressiveInlining)] public static implicit operator (Number, Number, Number, Number, Number, Number, Number, Number)(Vector8 self) => (self.X0, self.X1, self.X2, self.X3, self.X4, self.X5, self.X6, self.X7);
        [MethodImpl(AggressiveInlining)] public static implicit operator Vector8((Number, Number, Number, Number, Number, Number, Number, Number) value) => new Vector8(value.Item1, value.Item2, value.Item3, value.Item4, value.Item5, value.Item6, value.Item7, value.Item8);
        [MethodImpl(AggressiveInlining)] public void Deconstruct(out Number x0, out Number x1, out Number x2, out Number x3, out Number x4, out Number x5, out Number x6, out Number x7) { x0 = X0; x1 = X1; x2 = X2; x3 = X3; x4 = X4; x5 = X5; x6 = X6; x7 = X7;  }

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Vector8 other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Vector8 other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Vector8 other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Vector8 a, Vector8 b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Vector8 a, Vector8 b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 8; }
        public IReadOnlyList<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(X0, X1, X2, X3, X4, X5, X6, X7); }
        [MethodImpl(AggressiveInlining)] public static Vector8 CreateFromComponents(IReadOnlyList<Number> numbers) => new Vector8(numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], numbers[5], numbers[6], numbers[7]);

        [MethodImpl(AggressiveInlining)] public static Vector8 CreateFromComponent(Number x) => new Vector8(x, x, x, x, x, x, x, x);

        // Implemented interface functions
        [MethodImpl(AggressiveInlining)] public Vector8 Add(Vector8 right) => this + right;
        [MethodImpl(AggressiveInlining)] public Vector8 Subtract(Vector8 right) => this - right;
        [MethodImpl(AggressiveInlining)] public Vector8 Multiply(Vector8 right) => this * right;
        [MethodImpl(AggressiveInlining)] public Vector8 Multiply(Number scalar) => this * scalar;
        [MethodImpl(AggressiveInlining)] public Vector8 Divide(Vector8 right) => this / right;
        [MethodImpl(AggressiveInlining)] public Vector8 Divide(Number scalar) => this / scalar;
        public Vector8 Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)] public Vector8 BitwiseAnd(Vector8 b) => this & b;
        [MethodImpl(AggressiveInlining)] public Vector8 BitwiseOr(Vector8 b) => this | b;
        public Vector8 Complement { [MethodImpl(AggressiveInlining)] get => ~this; }
        [MethodImpl(AggressiveInlining)] public Vector8 LessThan(Vector8 b) => this < b;
        [MethodImpl(AggressiveInlining)] public Vector8 LessThanOrEquals(Vector8 b) => this <= b;
        [MethodImpl(AggressiveInlining)] public Vector8 GreaterThan(Vector8 b) => this > b;
        [MethodImpl(AggressiveInlining)] public Vector8 GreaterThanOrEquals(Vector8 b) => this >= b;
        public Vector8 Normalize { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.GreaterThan(((Integer)0)) ? this.Divide(this.Magnitude) : Zero; } 
[MethodImpl(AggressiveInlining)] public Vector8 Reflect(Vector8 normal) => this.Subtract(normal.Multiply(this.Dot(normal).Multiply(((Number)2))));
[MethodImpl(AggressiveInlining)] public Vector8 Project(Vector8 other) => other.Multiply(this.Dot(other));
[MethodImpl(AggressiveInlining)] public Number Distance(Vector8 b) => b.Subtract(this).Magnitude;
[MethodImpl(AggressiveInlining)] public Number DistanceSquared(Vector8 b) => b.Subtract(this).MagnitudeSquared;
[MethodImpl(AggressiveInlining)] public Angle Angle(Vector8 b) => this.Dot(b).Divide(this.Magnitude.Multiply(b.Magnitude)).Acos;
[MethodImpl(AggressiveInlining)] public Boolean IsParallel(Vector8 b) => this.Dot(b).Abs.GreaterThanOrEquals(((Number)1).Subtract(Constants.Epsilon));
public Vector8 PlusOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One); } 
public Vector8 MinusOne { [MethodImpl(AggressiveInlining)] get  => this.Subtract(One); } 
// AMBIGUOUS FUNCTIONS 2
        /* Vectors_21.FromOne(x: IVector): IVector [Library]; */
        /* Core_7.FromOne(x: IVectorLike): IVectorLike [Library]; */
        public Vector8 FromOne { [MethodImpl(AggressiveInlining)] get  => this.Add(One).Negative; } 
public Number Length { [MethodImpl(AggressiveInlining)] get  => this.Magnitude; } 
public Number LengthSquared { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared; } 
[MethodImpl(AggressiveInlining)] public Vector8 Barycentric(Vector8 v2, Vector8 v3, Vector2 uv) => this.Add(v2.Subtract(this)).Multiply(uv.X).Add(v3.Subtract(this).Multiply(uv.Y));
[MethodImpl(AggressiveInlining)] public Vector8 Linear(Vector8 b, Number x) => this.Multiply(x).Add(b);
[MethodImpl(AggressiveInlining)] public Vector8 Quadratic(Vector8 b, Vector8 c, Number x) => this.Multiply(x.Sqr).Add(b.Multiply(x).Add(c));
[MethodImpl(AggressiveInlining)] public Vector8 Cubic(Vector8 b, Vector8 c, Vector8 d, Number x) => this.Multiply(x.Pow3).Add(b.Multiply(x.Sqr).Add(c.Multiply(x).Add(d)));
[MethodImpl(AggressiveInlining)] public Vector8 Quartic(Vector8 b, Vector8 c, Vector8 d, Vector8 e, Number x) => this.Multiply(x.Pow4).Add(b.Multiply(x.Pow3).Add(c.Multiply(x.Sqr).Add(d.Multiply(x).Add(e))));
[MethodImpl(AggressiveInlining)] public Vector8 LinearDerivative(Vector8 b, Number x) => this;
[MethodImpl(AggressiveInlining)] public Vector8 LinearSecondDerivative(Vector8 b, Number x) => default;
[MethodImpl(AggressiveInlining)] public Vector8 QuadraticDerivative(Vector8 b, Vector8 c, Number x) => this.Multiply(((Number)2)).Multiply(x).Add(b);
[MethodImpl(AggressiveInlining)] public Vector8 QuadraticSecondDerivative(Vector8 b, Vector8 c, Number x) => this.Multiply(((Number)2));
[MethodImpl(AggressiveInlining)] public Vector8 CubicDerivative(Vector8 b, Vector8 c, Vector8 d, Number x) => this.Multiply(((Number)3)).Multiply(x.Sqr).Add(b.Multiply(((Number)2)).Multiply(x).Add(c));
[MethodImpl(AggressiveInlining)] public Vector8 CubicSecondDerivative(Vector8 b, Vector8 c, Vector8 d, Number x) => this.Multiply(((Number)6)).Multiply(x).Add(b.Multiply(((Number)2)));
[MethodImpl(AggressiveInlining)] public Vector8 QuarticDerivative(Vector8 b, Vector8 c, Vector8 d, Vector8 e, Vector8 x) => this.Multiply(((Number)4)).Multiply(x.Pow3).Add(b.Multiply(((Number)3)).Multiply(x.Sqr).Add(c.Multiply(((Number)2)).Multiply(x).Add(d)));
[MethodImpl(AggressiveInlining)] public Vector8 QuarticSecondDerivative(Vector8 b, Vector8 c, Vector8 d, Vector8 e, Number x) => this.Multiply(((Number)12)).Multiply(x.Sqr).Add(b.Multiply(((Number)6)).Multiply(x).Add(c.Multiply(((Number)2))));
[MethodImpl(AggressiveInlining)] public Vector8 CubicBezier(Vector8 b, Vector8 c, Vector8 d, Number t) => this.Multiply(((Number)1).Subtract(t).Pow3).Add(b.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr.Multiply(t))).Add(c.Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Multiply(t.Sqr))).Add(d.Multiply(t.Pow3))));
[MethodImpl(AggressiveInlining)] public Vector8 CubicBezierDerivative(Vector8 b, Vector8 c, Vector8 d, Number t) => b.Subtract(this).Multiply(((Number)3).Multiply(((Number)1).Subtract(t).Sqr)).Add(c.Subtract(b).Multiply(((Number)6).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(d.Subtract(c).Multiply(((Number)3).Multiply(t.Sqr))));
[MethodImpl(AggressiveInlining)] public Vector8 CubicBezierSecondDerivative(Vector8 b, Vector8 c, Vector8 d, Number t) => c.Subtract(b.Multiply(((Number)2)).Add(this)).Multiply(((Number)6).Multiply(((Number)1).Subtract(t))).Add(d.Subtract(c.Multiply(((Number)2)).Add(b)).Multiply(((Number)6).Multiply(t)));
[MethodImpl(AggressiveInlining)] public Vector8 QuadraticBezier(Vector8 b, Vector8 c, Number t) => this.Multiply(((Number)1).Subtract(t).Sqr).Add(b.Multiply(((Number)2).Multiply(((Number)1).Subtract(t).Multiply(t))).Add(c.Multiply(t.Sqr)));
[MethodImpl(AggressiveInlining)] public Vector8 QuadraticBezierDerivative(Vector8 b, Vector8 c, Number t) => b.Subtract(this).Multiply(((Number)2).Multiply(((Number)1).Subtract(t))).Add(c.Subtract(b).Multiply(((Number)2).Multiply(t)));
[MethodImpl(AggressiveInlining)] public Vector8 QuadraticBezierSecondDerivative(Vector8 b, Vector8 c, Number t) => ((Number)2).Multiply(this.Subtract(b.Multiply(((Number)2)).Add(c)));
[MethodImpl(AggressiveInlining)] public Vector8 Hermite(Vector8 p1, Vector8 m0, Vector8 m1, Number t) => this.Multiply(((Number)2).Multiply(t.Pow3).Subtract(((Number)3).Multiply(t.Sqr).Add(((Number)1)))).Add(m0.Multiply(t.Pow3.Subtract(((Number)2).Multiply(t.Sqr).Add(t))).Add(p1.Multiply(((Number)2).Multiply(t.Pow3).Add(((Number)3).Multiply(t.Sqr)).Negative).Add(m1.Multiply(t.Pow3.Subtract(t.Sqr)))));
[MethodImpl(AggressiveInlining)] public Vector8 HermiteDerivative(Vector8 p1, Vector8 m0, Vector8 m1, Number t) => this.Multiply(((Number)6).Multiply(t.Sqr).Subtract(((Number)6).Multiply(t))).Add(m0.Multiply(((Number)3).Multiply(t.Sqr).Subtract(((Number)4).Multiply(t).Add(((Number)1)))).Add(p1.Multiply(((Number)6).Multiply(t.Sqr).Add(((Number)6).Multiply(t)).Negative).Add(m1.Multiply(((Number)3).Multiply(t.Sqr).Subtract(((Number)2).Multiply(t))))));
[MethodImpl(AggressiveInlining)] public Vector8 CatmullRom(Vector8 p1, Vector8 p2, Vector8 p3, Number t) => ((Number)0.5).Multiply(p1.Multiply(((Number)2)).Add(p2.Subtract(this).Multiply(t).Add(this.Multiply(((Number)2)).Subtract(p1.Multiply(((Number)5)).Add(p2.Multiply(((Number)4)).Subtract(p3))).Multiply(t.Sqr).Add(this.Add(p1.Multiply(((Number)3)).Subtract(p2.Multiply(((Number)3)).Add(p3))).Negative.Multiply(t.Pow3)))));
[MethodImpl(AggressiveInlining)] public Vector8 CatmullRomDerivative(Vector8 p1, Vector8 p2, Vector8 p3, Number t) => ((Number)0.5).Multiply(p2.Subtract(this).Add(((Number)2).Multiply(this.Multiply(((Number)2)).Subtract(p1.Multiply(((Number)5)).Add(p2.Multiply(((Number)4)).Subtract(p3))).Multiply(t)).Add(((Number)3).Multiply(this.Add(p1.Multiply(((Number)3)).Subtract(p2.Multiply(((Number)3)).Add(p3))).Negative.Multiply(t.Sqr)))));
public Vector8 SmoothStep { [MethodImpl(AggressiveInlining)] get  => this.Sqr.Multiply(this.Twice.Add(((Number)3)).Negative); } 
public Vector8 SmootherStep { [MethodImpl(AggressiveInlining)] get  => this.Pow3.Multiply(this.Multiply(((Number)6)).Subtract(((Number)15))).Add(((Number)10)); } 
public static Vector8 Zero { [MethodImpl(AggressiveInlining)] get  => Vector8.CreateFromComponent(((Number)0)); } 
public static Vector8 One { [MethodImpl(AggressiveInlining)] get  => Vector8.CreateFromComponent(((Number)1)); } 
public static Vector8 MinValue { [MethodImpl(AggressiveInlining)] get  => Vector8.CreateFromComponent(Number.MinValue); } 
public static Vector8 MaxValue { [MethodImpl(AggressiveInlining)] get  => Vector8.CreateFromComponent(Number.MaxValue); } 
[MethodImpl(AggressiveInlining)] public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this[((Integer)0)], (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this[((Integer)0)], (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Vector8 BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Vector8 BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Vector8 Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
public Vector8 Ceiling { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Ceiling); } 
[MethodImpl(AggressiveInlining)] public Vector8 Clamp(Vector8 min, Vector8 max) => this.ZipComponents(min, max, (a, b, c)  => a.Clamp(b, c));
[MethodImpl(AggressiveInlining)] public Vector8 CopySign(Vector8 y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
public Vector8 Exp { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Exp); } 
public Vector8 Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Floor); } 
[MethodImpl(AggressiveInlining)] public Vector8 FusedMultiplyAdd(Vector8 y, Vector8 z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Vector8 ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)] public Vector8 IEEERemainder(Vector8 y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Vector8 Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
public Vector8 Log2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log2); } 
[MethodImpl(AggressiveInlining)] public Vector8 MinMagnitude(Vector8 other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)] public Vector8 MaxMagnitude(Vector8 other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Vector8 NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)] public Vector8 Pow(Vector8 power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Vector8 ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Vector8 ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)] public Vector8 RoundToZero(Integer digits){
            var _var160 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var160));
        }

[MethodImpl(AggressiveInlining)] public Vector8 ScaleB(Integer n){
            var _var161 = n;
            return this.MapComponents((x)  => x.ScaleB(_var161));
        }

[MethodImpl(AggressiveInlining)] public Boolean AlmostEqual(Vector8 y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        /* Core_7.Average(x: IVectorLike,y: IVectorLike): IVectorLike [Library]; */
        /* Core_7.Average(a: IInterpolatable,b: IInterpolatable): IInterpolatable [Library]; */
        [MethodImpl(AggressiveInlining)] public Vector8 Average(Vector8 y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)] public Boolean Between(Vector8 a, Vector8 b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Vector8 ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Vector8 Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
[MethodImpl(AggressiveInlining)] public Vector8 InversePow(Vector8 y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)] public Vector8 Lerp(Vector8 b, Number t){
            var _var162 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var162));
        }

[MethodImpl(AggressiveInlining)] public Vector8 MultiplyEpsilon(Vector8 y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Vector8 Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Vector8 Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Vector8 Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Vector8 Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
[MethodImpl(AggressiveInlining)] public IReadOnlyList<Vector8> Sample(Vector8 b, Integer n){
            var _var164 = b;
            {
                var _var163 = this;
                return n.LinearSpace.Map((i)  => _var163.Lerp(_var164, i));
            }
        }

public Vector8 Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Vector8 Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Vector8 Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Vector8 Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Vector8 Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Vector8 Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Vector8 Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Vector8 Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Vector8 Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Vector8 Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Vector8 Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Vector8 Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Vector8 Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Vector8 Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)] public Number At(Integer n) => this.Components[n];
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)] public Vector8 MapComponents(System.Func<Number, Number> f) => Vector8.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)] public Vector8 ZipComponents(Vector8 b, System.Func<Number, Number, Number> f) => Vector8.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)] public Vector8 ZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Number> f) => Vector8.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)] public Boolean AllZipComponents(Vector8 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AllZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AnyZipComponents(Vector8 b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AnyZipComponents(Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)] public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)] public Vector8 Modulo(Vector8 b) => this % b;
        [MethodImpl(AggressiveInlining)] public Vector8 Modulo(Number other) => this % other;
    }
    // Extension methods for the type
    public static partial class Extensions
    {
        [MethodImpl(AggressiveInlining)] public static Vector8 Modulo(this Vector8 a, Vector8 b) => a.Modulo(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 Modulo(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).Modulo(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 Modulo(this Vector8 self, Number other) => self.Modulo(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 Modulo(this System.Runtime.Intrinsics.Vector256<float> self, Number other) => ((Vector8)self).Modulo(other);
        [MethodImpl(AggressiveInlining)] public static Number X0(this Vector8 self) => self.X0;
        [MethodImpl(AggressiveInlining)] public static Number X0(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X0;
        [MethodImpl(AggressiveInlining)] public static Number X1(this Vector8 self) => self.X1;
        [MethodImpl(AggressiveInlining)] public static Number X1(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X1;
        [MethodImpl(AggressiveInlining)] public static Number X2(this Vector8 self) => self.X2;
        [MethodImpl(AggressiveInlining)] public static Number X2(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X2;
        [MethodImpl(AggressiveInlining)] public static Number X3(this Vector8 self) => self.X3;
        [MethodImpl(AggressiveInlining)] public static Number X3(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X3;
        [MethodImpl(AggressiveInlining)] public static Number X4(this Vector8 self) => self.X4;
        [MethodImpl(AggressiveInlining)] public static Number X4(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X4;
        [MethodImpl(AggressiveInlining)] public static Number X5(this Vector8 self) => self.X5;
        [MethodImpl(AggressiveInlining)] public static Number X5(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X5;
        [MethodImpl(AggressiveInlining)] public static Number X6(this Vector8 self) => self.X6;
        [MethodImpl(AggressiveInlining)] public static Number X6(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X6;
        [MethodImpl(AggressiveInlining)] public static Number X7(this Vector8 self) => self.X7;
        [MethodImpl(AggressiveInlining)] public static Number X7(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).X7;
        [MethodImpl(AggressiveInlining)] public static Vector4 Lower(this Vector8 self) => self.Lower;
        [MethodImpl(AggressiveInlining)] public static Vector4 Lower(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Lower;
        [MethodImpl(AggressiveInlining)] public static Vector4 Upper(this Vector8 self) => self.Upper;
        [MethodImpl(AggressiveInlining)] public static Vector4 Upper(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Upper;
        [MethodImpl(AggressiveInlining)] public static Vector8 WithElement(this Vector8 self, Integer i, Number f) => self.WithElement(i, f);
        [MethodImpl(AggressiveInlining)] public static Vector8 WithElement(this System.Runtime.Intrinsics.Vector256<float> self, Integer i, Number f) => ((Vector8)self).WithElement(i, f);
        [MethodImpl(AggressiveInlining)] public static Vector8 WithLower(this Vector8 self, Vector4 lower) => self.WithLower(lower);
        [MethodImpl(AggressiveInlining)] public static Vector8 WithLower(this System.Runtime.Intrinsics.Vector256<float> self, Vector4 lower) => ((Vector8)self).WithLower(lower);
        [MethodImpl(AggressiveInlining)] public static Vector8 WithUpper(this Vector8 self, Vector4 upper) => self.WithUpper(upper);
        [MethodImpl(AggressiveInlining)] public static Vector8 WithUpper(this System.Runtime.Intrinsics.Vector256<float> self, Vector4 upper) => ((Vector8)self).WithUpper(upper);
        [MethodImpl(AggressiveInlining)] public static Vector8 Abs(this Vector8 self) => self.Abs;
        [MethodImpl(AggressiveInlining)] public static Vector8 Abs(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Abs;
        [MethodImpl(AggressiveInlining)] public static Vector8 Reciprocal(this Vector8 self) => self.Reciprocal;
        [MethodImpl(AggressiveInlining)] public static Vector8 Reciprocal(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Reciprocal;
        [MethodImpl(AggressiveInlining)] public static Vector8 ReciprocalSqrtEstimate(this Vector8 self) => self.ReciprocalSqrtEstimate;
        [MethodImpl(AggressiveInlining)] public static Vector8 ReciprocalSqrtEstimate(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).ReciprocalSqrtEstimate;
        [MethodImpl(AggressiveInlining)] public static Vector8 Sqrt(this Vector8 self) => self.Sqrt;
        [MethodImpl(AggressiveInlining)] public static Vector8 Sqrt(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Sqrt;
        [MethodImpl(AggressiveInlining)] public static Vector8 Sqr(this Vector8 self) => self.Sqr;
        [MethodImpl(AggressiveInlining)] public static Vector8 Sqr(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Sqr;
        [MethodImpl(AggressiveInlining)] public static Number Sum(this Vector8 self) => self.Sum;
        [MethodImpl(AggressiveInlining)] public static Number Sum(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Sum;
        [MethodImpl(AggressiveInlining)] public static Vector8 Add(this Vector8 left, Vector8 right) => left.Add(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Add(this System.Runtime.Intrinsics.Vector256<float> left, Vector8 right) => ((Vector8)left).Add(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Subtract(this Vector8 left, Vector8 right) => left.Subtract(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Subtract(this System.Runtime.Intrinsics.Vector256<float> left, Vector8 right) => ((Vector8)left).Subtract(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Multiply(this Vector8 left, Vector8 right) => left.Multiply(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Multiply(this System.Runtime.Intrinsics.Vector256<float> left, Vector8 right) => ((Vector8)left).Multiply(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Multiply(this Vector8 left, Number scalar) => left.Multiply(scalar);
        [MethodImpl(AggressiveInlining)] public static Vector8 Multiply(this System.Runtime.Intrinsics.Vector256<float> left, Number scalar) => ((Vector8)left).Multiply(scalar);
        [MethodImpl(AggressiveInlining)] public static Vector8 Divide(this Vector8 left, Vector8 right) => left.Divide(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Divide(this System.Runtime.Intrinsics.Vector256<float> left, Vector8 right) => ((Vector8)left).Divide(right);
        [MethodImpl(AggressiveInlining)] public static Vector8 Divide(this Vector8 left, Number scalar) => left.Divide(scalar);
        [MethodImpl(AggressiveInlining)] public static Vector8 Divide(this System.Runtime.Intrinsics.Vector256<float> left, Number scalar) => ((Vector8)left).Divide(scalar);
        [MethodImpl(AggressiveInlining)] public static Vector8 Negative(this Vector8 value) => value.Negative;
        [MethodImpl(AggressiveInlining)] public static Vector8 Negative(this System.Runtime.Intrinsics.Vector256<float> value) => ((Vector8)value).Negative;
        [MethodImpl(AggressiveInlining)] public static Vector8 AndNot(this Vector8 a, Vector8 b) => a.AndNot(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 AndNot(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).AndNot(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 BitwiseAnd(this Vector8 a, Vector8 b) => a.BitwiseAnd(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 BitwiseAnd(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).BitwiseAnd(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 BitwiseOr(this Vector8 a, Vector8 b) => a.BitwiseOr(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 BitwiseOr(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).BitwiseOr(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 Complement(this Vector8 a) => a.Complement;
        [MethodImpl(AggressiveInlining)] public static Vector8 Complement(this System.Runtime.Intrinsics.Vector256<float> a) => ((Vector8)a).Complement;
        [MethodImpl(AggressiveInlining)] public static Vector8 ConditionalSelect(this Vector8 condition, Vector8 a, Vector8 b) => condition.ConditionalSelect(a, b);
        [MethodImpl(AggressiveInlining)] public static Vector8 ConditionalSelect(this System.Runtime.Intrinsics.Vector256<float> condition, Vector8 a, Vector8 b) => ((Vector8)condition).ConditionalSelect(a, b);
        [MethodImpl(AggressiveInlining)] public static Vector8 LessThan(this Vector8 a, Vector8 b) => a.LessThan(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 LessThan(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).LessThan(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 LessThanOrEquals(this Vector8 a, Vector8 b) => a.LessThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 LessThanOrEquals(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).LessThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 GreaterThan(this Vector8 a, Vector8 b) => a.GreaterThan(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 GreaterThan(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).GreaterThan(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 GreaterThanOrEquals(this Vector8 a, Vector8 b) => a.GreaterThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 GreaterThanOrEquals(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).GreaterThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 Max(this Vector8 self, Vector8 other) => self.Max(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 Max(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 other) => ((Vector8)self).Max(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 Min(this Vector8 self, Vector8 other) => self.Min(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 Min(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 other) => ((Vector8)self).Min(other);
        [MethodImpl(AggressiveInlining)] public static Number Dot(this Vector8 self, Vector8 other) => self.Dot(other);
        [MethodImpl(AggressiveInlining)] public static Number Dot(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 other) => ((Vector8)self).Dot(other);
        [MethodImpl(AggressiveInlining)] public static Number FirstElement(this Vector8 self) => self.FirstElement;
        [MethodImpl(AggressiveInlining)] public static Number FirstElement(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).FirstElement;
        [MethodImpl(AggressiveInlining)] public static Vector8 Normalize(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Normalize;
        [MethodImpl(AggressiveInlining)] public static Vector8 Reflect(this System.Runtime.Intrinsics.Vector256<float> v, Vector8 normal) => ((Vector8)v).Reflect(normal);
        [MethodImpl(AggressiveInlining)] public static Vector8 Project(this System.Runtime.Intrinsics.Vector256<float> v, Vector8 other) => ((Vector8)v).Project(other);
        [MethodImpl(AggressiveInlining)] public static Number Distance(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).Distance(b);
        [MethodImpl(AggressiveInlining)] public static Number DistanceSquared(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).DistanceSquared(b);
        [MethodImpl(AggressiveInlining)] public static Angle Angle(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).Angle(b);
        [MethodImpl(AggressiveInlining)] public static Boolean IsParallel(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b) => ((Vector8)a).IsParallel(b);
        [MethodImpl(AggressiveInlining)] public static Vector8 PlusOne(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).PlusOne;
        [MethodImpl(AggressiveInlining)] public static Vector8 MinusOne(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).MinusOne;
        [MethodImpl(AggressiveInlining)] public static Vector8 FromOne(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).FromOne;
        [MethodImpl(AggressiveInlining)] public static Number Length(this System.Runtime.Intrinsics.Vector256<float> a) => ((Vector8)a).Length;
        [MethodImpl(AggressiveInlining)] public static Number LengthSquared(this System.Runtime.Intrinsics.Vector256<float> a) => ((Vector8)a).LengthSquared;
        [MethodImpl(AggressiveInlining)] public static Vector8 Barycentric(this System.Runtime.Intrinsics.Vector256<float> v1, Vector8 v2, Vector8 v3, Vector2 uv) => ((Vector8)v1).Barycentric(v2, v3, uv);
        [MethodImpl(AggressiveInlining)] public static Vector8 Linear(this System.Runtime.Intrinsics.Vector256<float> m, Vector8 b, Number x) => ((Vector8)m).Linear(b, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 Quadratic(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number x) => ((Vector8)a).Quadratic(b, c, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 Cubic(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number x) => ((Vector8)a).Cubic(b, c, d, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 Quartic(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Vector8 e, Number x) => ((Vector8)a).Quartic(b, c, d, e, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 LinearDerivative(this System.Runtime.Intrinsics.Vector256<float> m, Vector8 b, Number x) => ((Vector8)m).LinearDerivative(b, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 LinearSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> m, Vector8 b, Number x) => ((Vector8)m).LinearSecondDerivative(b, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuadraticDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number x) => ((Vector8)a).QuadraticDerivative(b, c, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuadraticSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number x) => ((Vector8)a).QuadraticSecondDerivative(b, c, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 CubicDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number x) => ((Vector8)a).CubicDerivative(b, c, d, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 CubicSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number x) => ((Vector8)a).CubicSecondDerivative(b, c, d, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuarticDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Vector8 e, Vector8 x) => ((Vector8)a).QuarticDerivative(b, c, d, e, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuarticSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Vector8 e, Number x) => ((Vector8)a).QuarticSecondDerivative(b, c, d, e, x);
        [MethodImpl(AggressiveInlining)] public static Vector8 CubicBezier(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number t) => ((Vector8)a).CubicBezier(b, c, d, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 CubicBezierDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number t) => ((Vector8)a).CubicBezierDerivative(b, c, d, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 CubicBezierSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Vector8 d, Number t) => ((Vector8)a).CubicBezierSecondDerivative(b, c, d, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuadraticBezier(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number t) => ((Vector8)a).QuadraticBezier(b, c, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuadraticBezierDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number t) => ((Vector8)a).QuadraticBezierDerivative(b, c, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 QuadraticBezierSecondDerivative(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, Number t) => ((Vector8)a).QuadraticBezierSecondDerivative(b, c, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 Hermite(this System.Runtime.Intrinsics.Vector256<float> p0, Vector8 p1, Vector8 m0, Vector8 m1, Number t) => ((Vector8)p0).Hermite(p1, m0, m1, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 HermiteDerivative(this System.Runtime.Intrinsics.Vector256<float> p0, Vector8 p1, Vector8 m0, Vector8 m1, Number t) => ((Vector8)p0).HermiteDerivative(p1, m0, m1, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 CatmullRom(this System.Runtime.Intrinsics.Vector256<float> p0, Vector8 p1, Vector8 p2, Vector8 p3, Number t) => ((Vector8)p0).CatmullRom(p1, p2, p3, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 CatmullRomDerivative(this System.Runtime.Intrinsics.Vector256<float> p0, Vector8 p1, Vector8 p2, Vector8 p3, Number t) => ((Vector8)p0).CatmullRomDerivative(p1, p2, p3, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 SmoothStep(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).SmoothStep;
        [MethodImpl(AggressiveInlining)] public static Vector8 SmootherStep(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).SmootherStep;
        [MethodImpl(AggressiveInlining)] public static Number Reduce(this System.Runtime.Intrinsics.Vector256<float> v, Number initial, System.Func<Number, Number, Number> f) => ((Vector8)v).Reduce(initial, f);
        [MethodImpl(AggressiveInlining)] public static Number MinComponent(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).MinComponent;
        [MethodImpl(AggressiveInlining)] public static Number MaxComponent(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).MaxComponent;
        [MethodImpl(AggressiveInlining)] public static Number SumComponents(this System.Runtime.Intrinsics.Vector256<float> v) => ((Vector8)v).SumComponents;
        [MethodImpl(AggressiveInlining)] public static Number SumSqrComponents(this System.Runtime.Intrinsics.Vector256<float> v) => ((Vector8)v).SumSqrComponents;
        [MethodImpl(AggressiveInlining)] public static Number AvgComponent(this System.Runtime.Intrinsics.Vector256<float> v) => ((Vector8)v).AvgComponent;
        [MethodImpl(AggressiveInlining)] public static Number Magnitude(this System.Runtime.Intrinsics.Vector256<float> v) => ((Vector8)v).Magnitude;
        [MethodImpl(AggressiveInlining)] public static Number MagnitudeSquared(this System.Runtime.Intrinsics.Vector256<float> v) => ((Vector8)v).MagnitudeSquared;
        [MethodImpl(AggressiveInlining)] public static Vector8 BitDecrement(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).BitDecrement;
        [MethodImpl(AggressiveInlining)] public static Vector8 BitIncrement(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).BitIncrement;
        [MethodImpl(AggressiveInlining)] public static Vector8 Cbrt(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Cbrt;
        [MethodImpl(AggressiveInlining)] public static Vector8 Ceiling(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Ceiling;
        [MethodImpl(AggressiveInlining)] public static Vector8 Clamp(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 min, Vector8 max) => ((Vector8)self).Clamp(min, max);
        [MethodImpl(AggressiveInlining)] public static Vector8 CopySign(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 y) => ((Vector8)self).CopySign(y);
        [MethodImpl(AggressiveInlining)] public static Vector8 Exp(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Exp;
        [MethodImpl(AggressiveInlining)] public static Vector8 Floor(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Floor;
        [MethodImpl(AggressiveInlining)] public static Vector8 FusedMultiplyAdd(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 y, Vector8 z) => ((Vector8)self).FusedMultiplyAdd(y, z);
        [MethodImpl(AggressiveInlining)] public static Vector8 ILogB(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).ILogB;
        [MethodImpl(AggressiveInlining)] public static Vector8 IEEERemainder(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 y) => ((Vector8)self).IEEERemainder(y);
        [MethodImpl(AggressiveInlining)] public static Vector8 Log10(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Log10;
        [MethodImpl(AggressiveInlining)] public static Vector8 Log2(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).Log2;
        [MethodImpl(AggressiveInlining)] public static Vector8 MinMagnitude(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 other) => ((Vector8)self).MinMagnitude(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 MaxMagnitude(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 other) => ((Vector8)self).MaxMagnitude(other);
        [MethodImpl(AggressiveInlining)] public static Vector8 NaturalLog(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).NaturalLog;
        [MethodImpl(AggressiveInlining)] public static Vector8 Pow(this System.Runtime.Intrinsics.Vector256<float> self, Vector8 power) => ((Vector8)self).Pow(power);
        [MethodImpl(AggressiveInlining)] public static Vector8 ReciprocalEstimate(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).ReciprocalEstimate;
        [MethodImpl(AggressiveInlining)] public static Vector8 ReciprocalSquareRootEstimate(this System.Runtime.Intrinsics.Vector256<float> self) => ((Vector8)self).ReciprocalSquareRootEstimate;
        [MethodImpl(AggressiveInlining)] public static Vector8 RoundToZero(this System.Runtime.Intrinsics.Vector256<float> self, Integer digits) => ((Vector8)self).RoundToZero(digits);
        [MethodImpl(AggressiveInlining)] public static Vector8 ScaleB(this System.Runtime.Intrinsics.Vector256<float> self, Integer n) => ((Vector8)self).ScaleB(n);
        [MethodImpl(AggressiveInlining)] public static Boolean AlmostEqual(this System.Runtime.Intrinsics.Vector256<float> x, Vector8 y) => ((Vector8)x).AlmostEqual(y);
        [MethodImpl(AggressiveInlining)] public static Boolean AlmostZero(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).AlmostZero;
        [MethodImpl(AggressiveInlining)] public static Vector8 Average(this System.Runtime.Intrinsics.Vector256<float> x, Vector8 y) => ((Vector8)x).Average(y);
        [MethodImpl(AggressiveInlining)] public static Boolean Between(this System.Runtime.Intrinsics.Vector256<float> x, Vector8 a, Vector8 b) => ((Vector8)x).Between(a, b);
        [MethodImpl(AggressiveInlining)] public static Boolean Between01(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Between01;
        [MethodImpl(AggressiveInlining)] public static Vector8 ClampZeroOne(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).ClampZeroOne;
        [MethodImpl(AggressiveInlining)] public static Vector8 Fract(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Fract;
        [MethodImpl(AggressiveInlining)] public static Vector8 InversePow(this System.Runtime.Intrinsics.Vector256<float> x, Vector8 y) => ((Vector8)x).InversePow(y);
        [MethodImpl(AggressiveInlining)] public static Vector8 Lerp(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Number t) => ((Vector8)a).Lerp(b, t);
        [MethodImpl(AggressiveInlining)] public static Vector8 MultiplyEpsilon(this System.Runtime.Intrinsics.Vector256<float> x, Vector8 y) => ((Vector8)x).MultiplyEpsilon(y);
        [MethodImpl(AggressiveInlining)] public static Vector8 Pow2(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Pow2;
        [MethodImpl(AggressiveInlining)] public static Vector8 Pow3(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Pow3;
        [MethodImpl(AggressiveInlining)] public static Vector8 Pow4(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Pow4;
        [MethodImpl(AggressiveInlining)] public static Vector8 Pow5(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Pow5;
        [MethodImpl(AggressiveInlining)] public static IReadOnlyList<Vector8> Sample(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Integer n) => ((Vector8)a).Sample(b, n);
        [MethodImpl(AggressiveInlining)] public static Vector8 Half(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Half;
        [MethodImpl(AggressiveInlining)] public static Vector8 Quarter(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Quarter;
        [MethodImpl(AggressiveInlining)] public static Vector8 Eight(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Eight;
        [MethodImpl(AggressiveInlining)] public static Vector8 Sixteenth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Sixteenth;
        [MethodImpl(AggressiveInlining)] public static Vector8 Tenth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Tenth;
        [MethodImpl(AggressiveInlining)] public static Vector8 Twice(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Twice;
        [MethodImpl(AggressiveInlining)] public static Vector8 Hundred(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Hundred;
        [MethodImpl(AggressiveInlining)] public static Vector8 Thousand(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Thousand;
        [MethodImpl(AggressiveInlining)] public static Vector8 Million(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Million;
        [MethodImpl(AggressiveInlining)] public static Vector8 Billion(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Billion;
        [MethodImpl(AggressiveInlining)] public static Vector8 Hundredth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Hundredth;
        [MethodImpl(AggressiveInlining)] public static Vector8 Thousandth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Thousandth;
        [MethodImpl(AggressiveInlining)] public static Vector8 Millionth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Millionth;
        [MethodImpl(AggressiveInlining)] public static Vector8 Billionth(this System.Runtime.Intrinsics.Vector256<float> x) => ((Vector8)x).Billionth;
        [MethodImpl(AggressiveInlining)] public static Number At(this System.Runtime.Intrinsics.Vector256<float> xs, Integer n) => ((Vector8)xs).At(n);
        [MethodImpl(AggressiveInlining)] public static Vector8 MapComponents(this System.Runtime.Intrinsics.Vector256<float> x, System.Func<Number, Number> f) => ((Vector8)x).MapComponents(f);
        [MethodImpl(AggressiveInlining)] public static Vector8 ZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, System.Func<Number, Number, Number> f) => ((Vector8)a).ZipComponents(b, f);
        [MethodImpl(AggressiveInlining)] public static Vector8 ZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, System.Func<Number, Number, Number, Number> f) => ((Vector8)a).ZipComponents(b, c, f);
        [MethodImpl(AggressiveInlining)] public static Boolean AllZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, System.Func<Number, Number, Boolean> f) => ((Vector8)a).AllZipComponents(b, f);
        [MethodImpl(AggressiveInlining)] public static Boolean AllZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => ((Vector8)a).AllZipComponents(b, c, f);
        [MethodImpl(AggressiveInlining)] public static Boolean AnyZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, System.Func<Number, Number, Boolean> f) => ((Vector8)a).AnyZipComponents(b, f);
        [MethodImpl(AggressiveInlining)] public static Boolean AnyZipComponents(this System.Runtime.Intrinsics.Vector256<float> a, Vector8 b, Vector8 c, System.Func<Number, Number, Number, Boolean> f) => ((Vector8)a).AnyZipComponents(b, c, f);
        [MethodImpl(AggressiveInlining)] public static Boolean AllComponents(this System.Runtime.Intrinsics.Vector256<float> x, System.Func<Number, Boolean> predicate) => ((Vector8)x).AllComponents(predicate);
        [MethodImpl(AggressiveInlining)] public static Boolean AnyComponent(this System.Runtime.Intrinsics.Vector256<float> x, System.Func<Number, Boolean> predicate) => ((Vector8)x).AnyComponent(predicate);
    }
}
