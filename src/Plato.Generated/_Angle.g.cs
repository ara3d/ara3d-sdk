// Autogenerated file: DO NOT EDIT
// Created on 2025-06-05 2:34:17 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;
using Ara3D.Collections;

namespace Ara3D.Geometry
{
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public partial struct Angle: IMeasure<Angle>
    {
        // Static factory function
        [MethodImpl(AggressiveInlining)] public static Angle Create() => new Angle();

        // Static default implementation
        public static readonly Angle Default = default;

        // Object virtual function overrides: Equals, GetHashCode, ToString
        [MethodImpl(AggressiveInlining)] public Boolean Equals(Angle other) => Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public Boolean NotEquals(Angle other) => !Value.Equals(other.Value);
        [MethodImpl(AggressiveInlining)] public override bool Equals(object obj) => obj is Angle other ? Equals(other) : false;
        [MethodImpl(AggressiveInlining)] public static Boolean operator==(Angle a, Angle b) => a.Equals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean operator!=(Angle a, Angle b) => !a.Equals(b);
        [MethodImpl(AggressiveInlining)] public override int GetHashCode() => Value.GetHashCode();
        [MethodImpl(AggressiveInlining)] public override string ToString() => Value.ToString();

        // Explicit implementation of interfaces by forwarding properties to fields

        // IArrayLike predefined functions
        public Integer NumComponents { [MethodImpl(AggressiveInlining)] get => 1; }
        public IReadOnlyList<Number> Components { [MethodImpl(AggressiveInlining)] get => Intrinsics.MakeArray<Number>(Value); }
        [MethodImpl(AggressiveInlining)] public static Angle CreateFromComponents(IReadOnlyList<Number> numbers) => new Angle(numbers[0]);

        [MethodImpl(AggressiveInlining)] public static Angle CreateFromComponent(Number x) => new Angle(x);

        // Implemented interface functions
        public Number Turns { [MethodImpl(AggressiveInlining)] get  => this.Radians.Divide(Constants.TwoPi); } 
public Number Degrees { [MethodImpl(AggressiveInlining)] get  => this.Turns.Multiply(((Number)360)); } 
public Number Gradians { [MethodImpl(AggressiveInlining)] get  => this.Turns.Multiply(((Number)400)); } 
public Number Sec { [MethodImpl(AggressiveInlining)] get  => this.Cos.Reciprocal; } 
public Number Csc { [MethodImpl(AggressiveInlining)] get  => this.Sin.Reciprocal; } 
public Number Cot { [MethodImpl(AggressiveInlining)] get  => this.Tan.Reciprocal; } 
public Point2D UnitCircle { [MethodImpl(AggressiveInlining)] get  => (this.Cos, this.Sin); } 
[MethodImpl(AggressiveInlining)] public Point2D Circle(Point2D center, Number radius) => this.UnitCircle.Multiply(radius).Add(center);
[MethodImpl(AggressiveInlining)] public Point2D Ellipse(Point2D center, Vector2 size) => this.UnitCircle.Multiply(size).Add(center);
[MethodImpl(AggressiveInlining)] public Point2D Epicycloid(Number R, Number r) => (R.Add(r).Multiply(this.Cos).Subtract(r.Multiply(R.Add(r).Multiply(this.Divide(r).Cos))), R.Add(r).Multiply(this.Sin).Subtract(r.Multiply(R.Add(r).Multiply(this.Divide(r).Sin))));
[MethodImpl(AggressiveInlining)] public Point2D Hypocycloid(Number R, Number r) => (R.Subtract(r).Multiply(this.Cos).Add(r.Multiply(R.Subtract(r).Multiply(this.Divide(r).Cos))), R.Subtract(r).Multiply(this.Sin).Subtract(r.Multiply(R.Subtract(r).Multiply(this.Divide(r).Sin))));
[MethodImpl(AggressiveInlining)] public Point2D Epitrochoid(Number R, Number r, Number d) => (R.Add(r).Multiply(this.Cos).Subtract(d.Multiply(R.Add(r).Multiply(this.Divide(r).Cos))), R.Add(r).Multiply(this.Sin).Subtract(d.Multiply(R.Add(r).Multiply(this.Divide(r).Sin))));
[MethodImpl(AggressiveInlining)] public Point2D Hypotrochoid(Number R, Number r, Number d) => (R.Subtract(r).Multiply(this.Cos).Add(d.Multiply(R.Subtract(r).Multiply(this.Divide(r).Cos))), R.Subtract(r).Multiply(this.Sin).Subtract(d.Multiply(R.Subtract(r).Multiply(this.Divide(r).Sin))));
public Point2D ButterflyCurve { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)6)).ButterflyCurveSection; } 
public Point2D ButterflyCurveSection { [MethodImpl(AggressiveInlining)] get  => (this.Multiply(this.Cos.Exp.Subtract(((Number)2).Multiply(this.Multiply(((Number)4)).Cos).Subtract(this.Divide(((Number)12)).Sin.Pow(((Number)5))))).Sin, this.Multiply(this.Cos.Exp.Subtract(((Number)2).Multiply(this.Multiply(((Number)4)).Cos).Subtract(this.Divide(((Number)12)).Sin.Pow(((Number)5))))).Cos); } 
[MethodImpl(AggressiveInlining)] public Point2D Lissajous(Number a, Number b, Angle d) => (this.Add(d).Sin, b.Turns.Sin);
public Number CycloidOfCeva { [MethodImpl(AggressiveInlining)] get  => ((Number)1).Add(this.Multiply(((Number)2)).Cos.Multiply(((Number)2))); } 
[MethodImpl(AggressiveInlining)] public Number Limacon(Number a, Number b) => a.Multiply(this.Cos).Add(b);
public Number Cardoid { [MethodImpl(AggressiveInlining)] get  => ((Number)1).Add(this.Cos); } 
[MethodImpl(AggressiveInlining)] public Number TschirnhausenCubic(Number a) => a.Multiply(this.Divide(((Number)3)).Sec.Pow3);
[MethodImpl(AggressiveInlining)] public Number Rose(Number k) => k.Multiply(this.Cos);
[MethodImpl(AggressiveInlining)] public Number ArchimedeanSpiral(Number a, Number b) => a.Add(b.Multiply(this.Turns));
[MethodImpl(AggressiveInlining)] public Number ConicSection(Number semiLatusRectum, Number eccentricity) => semiLatusRectum.Divide(((Number)1).Subtract(eccentricity.Multiply(this.Cos)));
[MethodImpl(AggressiveInlining)] public Number LemniscateOfBernoulli(Number a) => a.Sqr.Multiply(this.Multiply(((Number)2)).Cos).Sqrt;
[MethodImpl(AggressiveInlining)] public Number TrisectrixOfMaclaurin(Number a) => ((Number)2).Multiply(a).Divide(this.Divide(((Number)3)).Cos);
[MethodImpl(AggressiveInlining)] public Number ConchoidOfDeSluze(Number a) => this.Sec.Add(a.Multiply(this.Cos));
[MethodImpl(AggressiveInlining)] public Number SinusoidalSpiral(Number a, Number n) => a.Pow(n).Multiply(this.Multiply(n).Cos).InversePow(a);
[MethodImpl(AggressiveInlining)] public Number FermatsSpiral(Number a) => a.Multiply(this.Turns.Sqr).Sqrt;
[MethodImpl(AggressiveInlining)] public Number LogarithmicSpiral(Number a, Number k) => a.Multiply(this.Radians.Multiply(k).Exp);
[MethodImpl(AggressiveInlining)] public Point3D TorusKnot(Number p, Number q){
            var r = this.Multiply(q).Cos.Add(((Number)2));
            var x = r.Multiply(this.Multiply(p).Cos);
            var y = r.Multiply(this.Multiply(p).Sin);
            var z = this.Multiply(q).Sin.Negative;
            return (x, y, z);
        }

public Point3D TrefoilKnot { [MethodImpl(AggressiveInlining)] get  => (this.Sin.Add(this.Multiply(((Number)2)).Sin.Multiply(((Number)2))), this.Cos.Add(this.Multiply(((Number)2)).Cos.Multiply(((Number)2))), this.Multiply(((Number)3)).Sin.Negative); } 
public Point3D FigureEightKnot { [MethodImpl(AggressiveInlining)] get  => (((Number)2).Add(this.Multiply(((Number)2)).Cos).Multiply(this.Multiply(((Number)3)).Cos), ((Number)2).Add(this.Multiply(((Number)2)).Cos).Multiply(this.Multiply(((Number)3)).Sin), this.Multiply(((Number)4)).Sin); } 
[MethodImpl(AggressiveInlining)] public Point3D Helix(Number revs) => (this.Multiply(revs).Sin, this.Multiply(revs).Cos, this.Turns);
[MethodImpl(AggressiveInlining)] public Angle Add(Angle b) => this + b;
        [MethodImpl(AggressiveInlining)] public Angle Subtract(Angle b) => this - b;
        [MethodImpl(AggressiveInlining)] public Angle Multiply(Number x) => this * x;
        [MethodImpl(AggressiveInlining)] public Angle Divide(Number x) => this / x;
        public Angle Negative { [MethodImpl(AggressiveInlining)] get => -this; }
        [MethodImpl(AggressiveInlining)] public Boolean LessThan(Angle b) => this < b;
        [MethodImpl(AggressiveInlining)] public Boolean LessThanOrEquals(Angle b) => this <= b;
        [MethodImpl(AggressiveInlining)] public Boolean GreaterThan(Angle b) => this > b;
        [MethodImpl(AggressiveInlining)] public Boolean GreaterThanOrEquals(Angle b) => this >= b;
        public AxisAngle RotateX { [MethodImpl(AggressiveInlining)] get  => (Constants.XAxis3D, this); } 
public AxisAngle RotateY { [MethodImpl(AggressiveInlining)] get  => (Constants.YAxis3D, this); } 
public AxisAngle RotateZ { [MethodImpl(AggressiveInlining)] get  => (Constants.ZAxis3D, this); } 
public static Angle Zero { [MethodImpl(AggressiveInlining)] get  => Angle.CreateFromComponent(((Number)0)); } 
public static Angle One { [MethodImpl(AggressiveInlining)] get  => Angle.CreateFromComponent(((Number)1)); } 
public static Angle MinValue { [MethodImpl(AggressiveInlining)] get  => Angle.CreateFromComponent(Ara3D.Geometry.Number.MinValue); } 
public static Angle MaxValue { [MethodImpl(AggressiveInlining)] get  => Angle.CreateFromComponent(Ara3D.Geometry.Number.MaxValue); } 
[MethodImpl(AggressiveInlining)] public Number Reduce(Number initial, System.Func<Number, Number, Number> f) => this.Components.Reduce(initial, f);
public Number MinComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this[((Integer)0)], (a, b)  => a.Min(b)); } 
public Number MaxComponent { [MethodImpl(AggressiveInlining)] get  => this.Reduce(this[((Integer)0)], (a, b)  => a.Max(b)); } 
public Number SumComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b)); } 
public Number SumSqrComponents { [MethodImpl(AggressiveInlining)] get  => this.Reduce(((Number)0), (a, b)  => a.Add(b.Multiply(b))); } 
public Number AvgComponent { [MethodImpl(AggressiveInlining)] get  => this.SumComponents.Divide(this.NumComponents); } 
public Number Magnitude { [MethodImpl(AggressiveInlining)] get  => this.MagnitudeSquared.Sqrt; } 
public Number MagnitudeSquared { [MethodImpl(AggressiveInlining)] get  => this.SumSqrComponents.Divide(this.NumComponents); } 
public Angle Abs { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Abs); } 
public Angle BitDecrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitDecrement); } 
public Angle BitIncrement { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.BitIncrement); } 
public Angle Cbrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Cbrt); } 
public Angle Ceiling { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Ceiling); } 
[MethodImpl(AggressiveInlining)] public Angle Clamp(Angle min, Angle max) => this.ZipComponents(min, max, (a, b, c)  => a.Clamp(b, c));
[MethodImpl(AggressiveInlining)] public Angle CopySign(Angle y) => this.ZipComponents(y, (a, b)  => a.CopySign(b));
public Angle Exp { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Exp); } 
public Angle Floor { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Floor); } 
[MethodImpl(AggressiveInlining)] public Angle FusedMultiplyAdd(Angle y, Angle z) => this.ZipComponents(y, z, (a, b, c)  => a.FusedMultiplyAdd(b, c));
public Angle ILogB { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ILogB); } 
[MethodImpl(AggressiveInlining)] public Angle IEEERemainder(Angle y) => this.ZipComponents(y, (a, b)  => a.IEEERemainder(b));
public Angle Log10 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log10); } 
public Angle Log2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Log2); } 
[MethodImpl(AggressiveInlining)] public Angle Min(Angle other) => this.ZipComponents(other, (a, b)  => a.Min(b));
[MethodImpl(AggressiveInlining)] public Angle MinMagnitude(Angle other) => this.ZipComponents(other, (a, b)  => a.MinMagnitude(b));
[MethodImpl(AggressiveInlining)] public Angle Max(Angle other) => this.ZipComponents(other, (a, b)  => a.Max(b));
[MethodImpl(AggressiveInlining)] public Angle MaxMagnitude(Angle other) => this.ZipComponents(other, (a, b)  => a.MaxMagnitude(b));
public Angle NaturalLog { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.NaturalLog); } 
[MethodImpl(AggressiveInlining)] public Angle Pow(Angle power) => this.ZipComponents(power, (a, b)  => a.Pow(b));
public Angle Reciprocal { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.Reciprocal); } 
public Angle ReciprocalEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalEstimate); } 
public Angle ReciprocalSquareRootEstimate { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x)  => x.ReciprocalSquareRootEstimate); } 
[MethodImpl(AggressiveInlining)] public Angle RoundToZero(Integer digits){
            var _var77 = digits;
            return this.MapComponents((x)  => x.RoundToZero(_var77));
        }

[MethodImpl(AggressiveInlining)] public Angle ScaleB(Integer n){
            var _var78 = n;
            return this.MapComponents((x)  => x.ScaleB(_var78));
        }

[MethodImpl(AggressiveInlining)] public Boolean AlmostEqual(Angle y) => this.AllZipComponents(y, (a, b)  => a.AlmostEqual(b));
public Boolean AlmostZero { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x)  => x.AlmostZero); } 
// AMBIGUOUS FUNCTIONS 2
        /* Core_7.Average(x: IVectorLike,y: IVectorLike): IVectorLike [Library]; */
        /* Core_7.Average(a: IInterpolatable,b: IInterpolatable): IInterpolatable [Library]; */
        [MethodImpl(AggressiveInlining)] public Angle Average(Angle y) => this.Lerp(y, ((Number)0.5));
[MethodImpl(AggressiveInlining)] public Boolean Between(Angle a, Angle b) => this.AllZipComponents(a, b, (x1, a1, b1)  => x1.Between(a1, b1));
public Boolean Between01 { [MethodImpl(AggressiveInlining)] get  => this.AllComponents((x1)  => x1.Between01); } 
public Angle ClampZeroOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.ClampZeroOne); } 
public Angle Fract { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Fract); } 
public Angle FromOne { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.FromOne); } 
[MethodImpl(AggressiveInlining)] public Angle InversePow(Angle y) => this.ZipComponents(y, (x1, y1)  => x1.InversePow(y1));
[MethodImpl(AggressiveInlining)] public Angle Lerp(Angle b, Number t){
            var _var79 = t;
            return this.ZipComponents(b, (a1, b1)  => a1.Lerp(b1, _var79));
        }

[MethodImpl(AggressiveInlining)] public Angle MultiplyEpsilon(Angle y) => this.ZipComponents(y, (x1, y1)  => x1.MultiplyEpsilon(y1));
public Angle Pow2 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow2); } 
public Angle Pow3 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow3); } 
public Angle Pow4 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow4); } 
public Angle Pow5 { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Pow5); } 
public Angle Sqr { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqr); } 
public Angle Sqrt { [MethodImpl(AggressiveInlining)] get  => this.MapComponents((x1)  => x1.Sqrt); } 
[MethodImpl(AggressiveInlining)] public IReadOnlyList<Angle> Sample(Angle b, Integer n){
            var _var81 = b;
            {
                var _var80 = this;
                return n.LinearSpace.Map((i)  => _var80.Lerp(_var81, i));
            }
        }

public Angle Half { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)2)); } 
public Angle Quarter { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)4)); } 
public Angle Eight { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)8)); } 
public Angle Sixteenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)16)); } 
public Angle Tenth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)10)); } 
public Angle Twice { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)2)); } 
public Angle Hundred { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)100)); } 
public Angle Thousand { [MethodImpl(AggressiveInlining)] get  => this.Multiply(((Number)1000)); } 
public Angle Million { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Thousand; } 
public Angle Billion { [MethodImpl(AggressiveInlining)] get  => this.Thousand.Million; } 
public Angle Hundredth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)100)); } 
public Angle Thousandth { [MethodImpl(AggressiveInlining)] get  => this.Divide(((Number)1000)); } 
public Angle Millionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Thousandth; } 
public Angle Billionth { [MethodImpl(AggressiveInlining)] get  => this.Thousandth.Millionth; } 
[MethodImpl(AggressiveInlining)] public Number At(Integer n) => this.Components[n];
public Number this[Integer n] { [MethodImpl(AggressiveInlining)]  get => At(n); }
        [MethodImpl(AggressiveInlining)] public Angle MapComponents(System.Func<Number, Number> f) => Angle.CreateFromComponents(this.Components.Map(f));
[MethodImpl(AggressiveInlining)] public Angle ZipComponents(Angle b, System.Func<Number, Number, Number> f) => Angle.CreateFromComponents(this.Components.Zip(b.Components, f));
[MethodImpl(AggressiveInlining)] public Angle ZipComponents(Angle b, Angle c, System.Func<Number, Number, Number, Number> f) => Angle.CreateFromComponents(this.Components.Zip(b.Components, c.Components, f));
[MethodImpl(AggressiveInlining)] public Boolean AllZipComponents(Angle b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AllZipComponents(Angle b, Angle c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).All((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AnyZipComponents(Angle b, System.Func<Number, Number, Boolean> f) => this.Components.Zip(b.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AnyZipComponents(Angle b, Angle c, System.Func<Number, Number, Number, Boolean> f) => this.Components.Zip(b.Components, c.Components, f).Any((x)  => x);
[MethodImpl(AggressiveInlining)] public Boolean AllComponents(System.Func<Number, Boolean> predicate) => this.Components.All(predicate);
[MethodImpl(AggressiveInlining)] public Boolean AnyComponent(System.Func<Number, Boolean> predicate) => this.Components.Any(predicate);
[MethodImpl(AggressiveInlining)] public Angle Lesser(Angle b) => this.LessThanOrEquals(b) ? this : b;
[MethodImpl(AggressiveInlining)] public Angle Greater(Angle b) => this.GreaterThanOrEquals(b) ? this : b;

        // Unimplemented interface functions
        [MethodImpl(AggressiveInlining)] public Angle Modulo(Number other) => this % other;
    }
    // Extension methods for the type
    public static class AngleExtensions
    {
        [MethodImpl(AggressiveInlining)] public static Angle Modulo(this Angle self, Number other) => self.Modulo(other);
        [MethodImpl(AggressiveInlining)] public static Number Cos(this Angle self) => self.Cos;
        [MethodImpl(AggressiveInlining)] public static Number Cosh(this Angle self) => self.Cosh;
        [MethodImpl(AggressiveInlining)] public static Number Sin(this Angle self) => self.Sin;
        [MethodImpl(AggressiveInlining)] public static Tuple2<Number, Number> SinCos(this Angle self) => self.SinCos;
        [MethodImpl(AggressiveInlining)] public static Number Sinh(this Angle self) => self.Sinh;
        [MethodImpl(AggressiveInlining)] public static Number Tan(this Angle self) => self.Tan;
        [MethodImpl(AggressiveInlining)] public static Number Tanh(this Angle self) => self.Tanh;
        [MethodImpl(AggressiveInlining)] public static Angle Add(this Angle a, Angle b) => a.Add(b);
        [MethodImpl(AggressiveInlining)] public static Angle Subtract(this Angle a, Angle b) => a.Subtract(b);
        [MethodImpl(AggressiveInlining)] public static Angle Multiply(this Angle a, Number x) => a.Multiply(x);
        [MethodImpl(AggressiveInlining)] public static Angle Divide(this Angle a, Number x) => a.Divide(x);
        [MethodImpl(AggressiveInlining)] public static Angle Negative(this Angle n) => n.Negative;
        [MethodImpl(AggressiveInlining)] public static Boolean LessThan(this Angle a, Angle b) => a.LessThan(b);
        [MethodImpl(AggressiveInlining)] public static Boolean LessThanOrEquals(this Angle a, Angle b) => a.LessThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Boolean GreaterThan(this Angle a, Angle b) => a.GreaterThan(b);
        [MethodImpl(AggressiveInlining)] public static Boolean GreaterThanOrEquals(this Angle a, Angle b) => a.GreaterThanOrEquals(b);
        [MethodImpl(AggressiveInlining)] public static Integer CompareTo(this Angle self, Angle other) => self.CompareTo(other);
        [MethodImpl(AggressiveInlining)] public static Number Radians(this Angle self) => self.Radians;
    }
}
