// Autogenerated file: DO NOT EDIT
// Created on 2025-06-07 6:14:52 PM

using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using static System.Runtime.CompilerServices.MethodImplOptions;
using Ara3D.Collections;

namespace Ara3D.Geometry
{
    public interface IAny<Self> where Self : IAny<Self>
    {
        Boolean Equals(Self b);
    }
public interface IValue
    {
    }
public interface IAdditive<Self> where Self : IAdditive<Self>
    {
        Self Add(Self b);
        Self Subtract(Self b);
        Self Negative { get; }
    }
public interface IScalarArithmetic<Self> where Self : IScalarArithmetic<Self>
    {
        Self Modulo(Number other);
        Self Divide(Number other);
        Self Multiply(Number other);
    }
public interface IInterpolatable<Self> where Self : IInterpolatable<Self>
    {
        Self Lerp(Self b, Number t);
    }
public interface IArrayLike<Self, T> where Self : IArrayLike<Self, T>
    {
        IReadOnlyList<T> Components { get; }
    }
public interface IVectorLike<Self>: IInterpolatable<Self>, IScalarArithmetic<Self>, IArrayLike<Self, Number> where Self : IVectorLike<Self>
    {
    }
public interface IMultiplicative<Self> where Self : IMultiplicative<Self>
    {
        Self Multiply(Self b);
    }
public interface IDivisible<Self> where Self : IDivisible<Self>
    {
        Self Divide(Self b);
    }
public interface IModulo<Self> where Self : IModulo<Self>
    {
        Self Modulo(Self b);
    }
public interface IArithmetic<Self>: IAdditive<Self>, IMultiplicative<Self>, IDivisible<Self>, IModulo<Self> where Self : IArithmetic<Self>
    {
    }
public interface INumerical<Self>: IVectorLike<Self>, IArithmetic<Self> where Self : INumerical<Self>
    {
    }
public interface IVector<Self>: INumerical<Self> where Self : IVector<Self>
    {
    }
public interface IOrderable<Self> where Self : IOrderable<Self>
    {
        Boolean LessThanOrEquals(Self y);
    }
public interface IInvertible<Self> where Self : IInvertible<Self>
    {
        Self Inverse { get; }
    }
public interface IMultiplicativeWithInverse<Self>: IMultiplicative<Self>, IInvertible<Self> where Self : IMultiplicativeWithInverse<Self>
    {
    }
public interface IRealNumber<Self>: IInterpolatable<Self>, IArithmetic<Self>, IScalarArithmetic<Self>, IOrderable<Self> where Self : IRealNumber<Self>
    {
    }
public interface IWholeNumber<Self>: IOrderable<Self>, IArithmetic<Self>, IInterpolatable<Self> where Self : IWholeNumber<Self>
    {
    }
public interface IMeasure<Self>: IVectorLike<Self>, IOrderable<Self> where Self : IMeasure<Self>
    {
    }
public interface ICoordinate
    {
    }
public interface IDifference<Self, T> where Self : IDifference<Self, T>
    {
        Self Add(T amount);
        Self Subtract(T amount);
        T Subtract(Self y);
    }
public interface IBoolean<Self> where Self : IBoolean<Self>
    {
        Self And(Self b);
        Self Or(Self b);
        Self Not { get; }
    }
public interface IInterval<T>: IValue
    {
        T Start { get; }
        T End { get; }
    }
public interface IBounds<TValue, TDelta>: IValue
    {
        TValue Min { get; }
        TValue Max { get; }
    }
public interface IRealFunction
    {
        Number Eval(Number x);
    }
public interface IAngularCurve2D: ICurve2D
    {
        Point2D Eval(Angle t);
    }
public interface IPolarCurve: IAngularCurve2D
    {
        Number GetRadius(Angle t);
    }
public interface IAngularCurve3D: ICurve3D
    {
        Point3D Eval(Angle t);
    }
public interface IGeometry
    {
    }
public interface IGeometry2D: IGeometry
    {
    }
public interface IGeometry3D: IGeometry
    {
    }
public interface IShape: IGeometry
    {
    }
public interface IShape2D: IShape, IGeometry2D
    {
    }
public interface IShape3D: IShape, IGeometry3D
    {
    }
public interface IOpenClosedShape: IShape
    {
        Boolean Closed { get; }
    }
public interface IOpenShape: IOpenClosedShape
    {
    }
public interface IClosedShape: IOpenClosedShape
    {
    }
public interface IOpenShape2D: IGeometry2D, IOpenShape
    {
    }
public interface IClosedShape2D: IGeometry2D, IClosedShape
    {
    }
public interface IOpenShape3D: IGeometry3D, IOpenShape
    {
    }
public interface IClosedShape3D: IGeometry3D, IClosedShape
    {
    }
public interface ICurve<TRange>: IProcedural<Number, TRange>, IOpenClosedShape
    {
    }
public interface IDistanceField2D: IProcedural<Vector2, Number>
    {
        Number Distance(Point2D p);
    }
public interface IDistanceField3D: IProcedural<Vector3, Number>
    {
        Number Distance(Point3D p);
    }
public interface ICurve1D: ICurve<Number>
    {
    }
public interface ICurve2D: IGeometry2D, ICurve<Point2D>
    {
    }
public interface IClosedCurve2D: ICurve2D, IClosedShape2D
    {
    }
public interface IOpenCurve2D: ICurve2D, IOpenShape2D
    {
    }
public interface ICurve3D: IGeometry3D, ICurve<Point3D>
    {
    }
public interface IClosedCurve3D: ICurve3D, IClosedShape3D
    {
    }
public interface IOpenCurve3D: ICurve3D, IOpenShape3D
    {
    }
public interface ISurface: IGeometry3D
    {
    }
public interface IProceduralSurface: IProcedural<Vector2, Point3D>, ISurface
    {
        Boolean ClosedX { get; }
        Boolean ClosedY { get; }
    }
public interface IExplicitSurface: IProcedural<Vector2, Number>, ISurface
    {
    }
public interface IImplicitProcedural<TDomain>: IProcedural<TDomain, Boolean>
    {
    }
public interface IImplicitVolume: IGeometry3D, IImplicitProcedural<Point3D>
    {
    }
public interface IPolyLine2D<Self>: IPointGeometry2D<Self>, IOpenClosedShape, ICurve2D where Self : IPolyLine2D<Self>
    {
    }
public interface IPolyLine3D<Self>: IPointGeometry3D<Self>, IOpenClosedShape, ICurve3D where Self : IPolyLine3D<Self>
    {
    }
public interface IPolygon2D<Self>: IPolyLine2D<Self>, IClosedShape2D where Self : IPolygon2D<Self>
    {
    }
public interface IPolygon3D<Self>: IPolyLine3D<Self>, IClosedShape3D where Self : IPolygon3D<Self>
    {
    }
public interface ISolid: IProceduralSurface
    {
    }
public interface IPointGeometry2D<Self>: IGeometry2D, IDeformable2D<Self> where Self : IPointGeometry2D<Self>
    {
        IReadOnlyList<Point2D> Points { get; }
    }
public interface IPointGeometry3D<Self>: IGeometry3D, IDeformable3D<Self> where Self : IPointGeometry3D<Self>
    {
        IReadOnlyList<Point3D> Points { get; }
    }
public interface IGeometricPrimitive2D<Self>: IPointGeometry2D<Self> where Self : IGeometricPrimitive2D<Self>
    {
    }
public interface IGeometricPrimitive3D<Self>: IPointGeometry3D<Self> where Self : IGeometricPrimitive3D<Self>
    {
    }
public interface IPrimitiveGeometry2D<T>: IGeometry2D
    {
        IReadOnlyList<T> Primitives { get; }
    }
public interface IPrimitiveGeometry3D<PrimitiveT>: IGeometry3D
    {
        IReadOnlyList<PrimitiveT> Primitives { get; }
    }
public interface IIndexedGeometry3D<Self, IndexT>: IPointGeometry3D<Self> where Self : IIndexedGeometry3D<Self, IndexT>
    {
        IReadOnlyList<IndexT> FaceIndices { get; }
    }
public interface ITransformable3D<Self> where Self : ITransformable3D<Self>
    {
        Self Transform(Transform3D t);
    }
public interface IDeformable3D<Self>: ITransformable3D<Self> where Self : IDeformable3D<Self>
    {
        Self Deform(System.Func<Point3D, Point3D> f);
    }
public interface ITransformable2D<Self> where Self : ITransformable2D<Self>
    {
        Self Transform(Transform2D t);
    }
public interface IDeformable2D<Self>: ITransformable2D<Self> where Self : IDeformable2D<Self>
    {
        Self Deform(System.Func<Point2D, Point2D> f);
    }
public interface IProcedural<TIn, TOut>
    {
        TOut Eval(TIn t);
    }
public interface ITransform2D
    {
        Matrix3x2 Matrix { get; }
    }
public interface IRigidTransform2D: ITransform2D
    {
    }
public interface ITransform3D
    {
        Matrix4x4 Matrix { get; }
    }
public interface IRigidTransform3D: ITransform3D
    {
    }
public interface IRotation3D: IRigidTransform3D
    {
        Quaternion Quaternion { get; }
    }
}
